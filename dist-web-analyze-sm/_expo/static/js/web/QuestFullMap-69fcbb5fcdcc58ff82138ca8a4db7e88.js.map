{"version":3,"sources":["/components/quests/QuestFullMap.tsx","/node_modules/expo-file-system/src/index.ts","/node_modules/expo-file-system/src/FileSystem.ts","/node_modules/expo-file-system/src/ExponentFileSystem.web.ts","/node_modules/expo-file-system/src/ExponentFileSystemShim.ts","/node_modules/expo-file-system/src/FileSystem.types.ts","/node_modules/expo-sharing/build/Sharing.js","/node_modules/expo-sharing/build/ExpoSharing.web.js","/node_modules/expo-media-library/build/MediaLibrary.js","/node_modules/expo-media-library/build/ExpoMediaLibrary.web.js"],"sourcesContent":["// components/quests/QuestFullMap.tsx\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n    View,\n    StyleSheet,\n    Platform,\n    Pressable,\n    Text,\n    Dimensions,\n    TouchableOpacity,\n    Modal,\n    Alert,\n} from 'react-native';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport * as FileSystem from 'expo-file-system';\nimport * as Sharing from 'expo-sharing';\nimport * as MediaLibrary from 'expo-media-library';\n\ntype StepPoint = { lat: number; lng: number; title?: string };\n\ntype Mods = {\n    L: any;\n    MapContainer: any;\n    TileLayer: any;\n    Marker: any;\n    Polyline: any;\n    Popup: any;\n    FeatureGroup: any;\n    useMap: () => any;\n};\n\n// n теперь может быть числом или строкой \"1,2\"\nfunction numberIcon(L: any, n: number | string, active = false) {\n    const bg = active ? '#0ea5e9' : '#f59e0b';\n    const stroke = active ? '#0369a1' : '#b45309';\n    const html = `\n    <div style=\"\n      width:28px;height:28px;border-radius:9999px;\n      background:${bg};border:2px solid ${stroke};\n      color:#fff;display:flex;align-items:center;justify-content:center;\n      font-weight:800;font-size:12px;line-height:1;box-shadow:0 2px 6px rgba(0,0,0,.25);\n      padding:0 4px\n    \">${String(n)}</div>`;\n    return L.divIcon({ className: 'qmark', html, iconSize: [28, 28], iconAnchor: [14, 14] });\n}\n\nfunction buildGPX(pts: StepPoint[]) {\n    const trkpts = pts\n        .map(p => `<trkpt lat=\"${p.lat.toFixed(6)}\" lon=\"${p.lng.toFixed(6)}\"></trkpt>`)\n        .join('\\n');\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gpx creator=\"MeTravel\" version=\"1.1\" xmlns=\"http://www.topografix.com/GPX/1/1\">\n<trk><name>Quest route</name><trkseg>\n${trkpts}\n</trkseg></trk>\n</gpx>`;\n}\n\nfunction buildGeoJSON(pts: StepPoint[]) {\n    return JSON.stringify(\n        {\n            type: 'FeatureCollection',\n            features: [\n                ...pts.map((p, i) => ({\n                    type: 'Feature',\n                    geometry: { type: 'Point', coordinates: [p.lng, p.lat] },\n                    properties: { order: i + 1, title: p.title || `Точка ${i + 1}` },\n                })),\n                {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: pts.map(p => [p.lng, p.lat]),\n                    },\n                    properties: { name: 'Quest route' },\n                },\n            ],\n        },\n        null,\n        2\n    );\n}\n\nfunction downloadText(filename: string, text: string, type = 'text/plain') {\n    const blob = new Blob([text], { type });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n}\n\nasync function ensureDomToImage(): Promise<any> {\n    const w = window as any;\n    if (w.domtoimage) return w.domtoimage;\n\n    if (!(ensureDomToImage as any)._loader) {\n        (ensureDomToImage as any)._loader = new Promise<void>((resolve, reject) => {\n            const script = document.createElement('script');\n            script.src = 'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.3.0/dist/dom-to-image-more.min.js';\n            script.async = true;\n            script.onload = () => resolve();\n            script.onerror = (err) => {\n                (ensureDomToImage as any)._loader = null;\n                reject(err);\n            };\n            document.body.appendChild(script);\n        });\n    }\n\n    await (ensureDomToImage as any)._loader;\n\n    if (!w.domtoimage) {\n        throw new Error('dom-to-image failed to load from CDN');\n    }\n\n    return w.domtoimage;\n}\n\nexport default function QuestFullMap({\n                                         steps,\n                                         height = 520,\n                                         title = 'Карта квеста',\n                                     }: {\n    steps: StepPoint[];\n    height?: number;\n    title?: string;\n}) {\n    const [mods, setMods] = useState<Mods | null>(null);\n    const [exportMenuVisible, setExportMenuVisible] = useState(false);\n    const mapDivRef = useRef<HTMLDivElement | null>(null);\n    const insets = useSafeAreaInsets();\n    const { width: screenWidth } = Dimensions.get('window');\n\n    useEffect(() => {\n        (async () => {\n            try {\n                const ensureLeafletCSS = () => {\n                    const href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';\n                    if (!document.querySelector(`link[href=\"${href}\"]`)) {\n                        const link = document.createElement('link');\n                        link.rel = 'stylesheet';\n                        link.href = href;\n                        document.head.appendChild(link);\n                    }\n                };\n\n                const ensureLeaflet = async (): Promise<any> => {\n                    const w = window as any;\n                    if (w.L) return w.L;\n\n                    ensureLeafletCSS();\n\n                    if (!(ensureLeaflet as any)._loader) {\n                        (ensureLeaflet as any)._loader = new Promise<void>((resolve, reject) => {\n                            const script = document.createElement('script');\n                            script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';\n                            script.async = true;\n                            script.onload = () => resolve();\n                            script.onerror = (err) => {\n                                (ensureLeaflet as any)._loader = null;\n                                reject(err);\n                            };\n                            document.body.appendChild(script);\n                        });\n                    }\n\n                    await (ensureLeaflet as any)._loader;\n                    return w.L;\n                };\n\n                const L = await ensureLeaflet();\n                const RL = await import('react-leaflet');\n\n                // default marker images (not used for numberIcon, but keep leaflet happy)\n                // @ts-ignore\n                delete L.Icon.Default.prototype._getIconUrl;\n                L.Icon.Default.mergeOptions({\n                    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',\n                    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',\n                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',\n                });\n\n                // CSS загружается через CDN в других компонентах\n\n                setMods({\n                    L,\n                    MapContainer: (RL as any).MapContainer,\n                    TileLayer: (RL as any).TileLayer,\n                    Marker: (RL as any).Marker,\n                    Polyline: (RL as any).Polyline,\n                    Popup: (RL as any).Popup,\n                    FeatureGroup: (RL as any).FeatureGroup,\n                    useMap: (RL as any).useMap,\n                });\n            } catch (error) {\n                console.error('Error loading map modules:', error);\n            }\n        })();\n    }, []);\n\n    const points = useMemo(\n        () => steps.filter(s => Number.isFinite(s.lat) && Number.isFinite(s.lng)),\n        [steps]\n    );\n\n    // Группировка совпадающих координат\n    const groupedPoints = useMemo(() => {\n        type GP = { lat: number; lng: number; indexes: number[]; titles: string[] };\n        const map = new Map<string, GP>();\n        points.forEach((p, i) => {\n            const key = `${p.lat.toFixed(6)},${p.lng.toFixed(6)}`;\n            if (!map.has(key)) {\n                map.set(key, {\n                    lat: p.lat,\n                    lng: p.lng,\n                    indexes: [i + 1],\n                    titles: [p.title || `Точка ${i + 1}`],\n                });\n            } else {\n                const gp = map.get(key)!;\n                gp.indexes.push(i + 1);\n                gp.titles.push(p.title || `Точка ${i + 1}`);\n            }\n        });\n        // стабильный порядок для консистентности\n        return Array.from(map.values()).sort(\n            (a, b) => Math.min(...a.indexes) - Math.min(...b.indexes)\n        );\n    }, [points]);\n\n    // Mobile-specific export functions\n    const shareAsPNG = async () => {\n        try {\n            if (Platform.OS === 'web') {\n                exportPNG();\n                return;\n            }\n\n            const { status } = await MediaLibrary.requestPermissionsAsync();\n            if (status !== 'granted') {\n                Alert.alert('Требуется разрешение', 'Разрешите доступ к галерее для сохранения изображения');\n                return;\n            }\n\n            Alert.alert('Экспорт', 'Функция экспорта PNG на мобильных устройствах в разработке');\n        } catch (error) {\n            console.error('Error sharing PNG:', error);\n        }\n    };\n\n    const shareAsGPX = async () => {\n        try {\n            if (Platform.OS === 'web') {\n                exportGPX();\n                return;\n            }\n\n            const gpxContent = buildGPX(points);\n            const fileUri = `${FileSystem.cacheDirectory}${title.replace(/\\s+/g, '_')}.gpx`;\n\n            await FileSystem.writeAsStringAsync(fileUri, gpxContent);\n\n            if (await Sharing.isAvailableAsync()) {\n                await Sharing.shareAsync(fileUri, {\n                    mimeType: 'application/gpx+xml',\n                    dialogTitle: 'Поделиться маршрутом',\n                });\n            }\n        } catch (error) {\n            console.error('Error sharing GPX:', error);\n        }\n    };\n\n    const shareAsGeoJSON = async () => {\n        try {\n            if (Platform.OS === 'web') {\n                exportGeoJSON();\n                return;\n            }\n\n            const geoJsonContent = buildGeoJSON(points);\n            const fileUri = `${FileSystem.cacheDirectory}${title.replace(/\\s+/g, '_')}.geojson`;\n\n            await FileSystem.writeAsStringAsync(fileUri, geoJsonContent);\n\n            if (await Sharing.isAvailableAsync()) {\n                await Sharing.shareAsync(fileUri, {\n                    mimeType: 'application/geo+json',\n                    dialogTitle: 'Поделиться маршрутом',\n                });\n            }\n        } catch (error) {\n            console.error('Error sharing GeoJSON:', error);\n        }\n    };\n\n    const exportPNG = async () => {\n        try {\n            const domtoimage = await ensureDomToImage();\n            const node = mapDivRef.current;\n            if (!node) return;\n            const dataUrl = await (domtoimage as any).toPng(node, { quality: 1 });\n            const a = document.createElement('a');\n            a.href = dataUrl;\n            a.download = `${title.replace(/\\s+/g, '_')}.png`;\n            a.click();\n        } catch {\n            window.print();\n        }\n    };\n\n    const exportGPX = () =>\n        downloadText(`${title.replace(/\\s+/g, '_')}.gpx`, buildGPX(points), 'application/gpx+xml');\n    const exportGeoJSON = () =>\n        downloadText(`${title.replace(/\\s+/g, '_')}.geojson`, buildGeoJSON(points), 'application/geo+json');\n\n    if (!mods || points.length === 0) {\n        return (\n            <View style={[styles.wrap, { height }]}>\n                <Text style={styles.loadingText}>Загрузка карты...</Text>\n            </View>\n        );\n    }\n\n    const { L, MapContainer, TileLayer, Marker, Polyline, Popup, FeatureGroup, useMap } = mods;\n    const bounds = L.latLngBounds(points.map(p => [p.lat, p.lng] as [number, number])).pad(0.15);\n\n    // Безопасное подгоняние границ\n    const FitBounds: React.FC = () => {\n        const map = useMap();\n\n        useEffect(() => {\n            if (!map) return;\n\n            map.whenReady(() => {\n                const container: HTMLElement | undefined = map.getContainer?.();\n                if (!container) return;\n\n                const { clientWidth, clientHeight } = container;\n                if (!clientWidth || !clientHeight) return;\n\n                const current = map.getBounds?.();\n                const already = current && current.contains(bounds) && bounds.contains(current);\n\n                if (!already) {\n                    map.fitBounds(bounds, { animate: false });\n                }\n\n                requestAnimationFrame(() => map.invalidateSize());\n            });\n        }, [map, bounds]);\n\n        return null;\n    };\n\n    return (\n        <View style={[styles.wrap, { height }]}>\n            {/* Mobile-friendly toolbar */}\n            <View style={[styles.toolbar, { paddingTop: insets.top + 8 }]}>\n                <Text style={styles.toolbarTitle} numberOfLines={1}>\n                    {title}\n                </Text>\n\n                {Platform.OS === 'web' ? (\n                    <View style={styles.webButtons}>\n                        <Pressable style={styles.btn} onPress={exportPNG}>\n                            <Text style={styles.btnTxt}>PNG</Text>\n                        </Pressable>\n                        <Pressable style={styles.btn} onPress={exportGPX}>\n                            <Text style={styles.btnTxt}>GPX</Text>\n                        </Pressable>\n                        <Pressable style={styles.btn} onPress={exportGeoJSON}>\n                            <Text style={styles.btnTxt}>GeoJSON</Text>\n                        </Pressable>\n                    </View>\n                ) : (\n                    <TouchableOpacity\n                        style={styles.mobileMenuButton}\n                        onPress={() => setExportMenuVisible(true)}\n                    >\n                        <Text style={styles.mobileMenuText}>⋮</Text>\n                    </TouchableOpacity>\n                )}\n            </View>\n\n            {/* Mobile export menu modal */}\n            <Modal\n                visible={exportMenuVisible}\n                transparent={true}\n                animationType=\"slide\"\n                onRequestClose={() => setExportMenuVisible(false)}\n            >\n                <TouchableOpacity\n                    style={styles.modalOverlay}\n                    activeOpacity={1}\n                    onPress={() => setExportMenuVisible(false)}\n                >\n                    <View style={[styles.modalContent, { bottom: insets.bottom }]}>\n                        <Text style={styles.modalTitle}>Экспорт маршрута</Text>\n\n                        <TouchableOpacity\n                            style={styles.modalOption}\n                            onPress={() => {\n                                setExportMenuVisible(false);\n                                shareAsPNG();\n                            }}\n                        >\n                            <Text style={styles.modalOptionText}>Сохранить как PNG</Text>\n                        </TouchableOpacity>\n\n                        <TouchableOpacity\n                            style={styles.modalOption}\n                            onPress={() => {\n                                setExportMenuVisible(false);\n                                shareAsGPX();\n                            }}\n                        >\n                            <Text style={styles.modalOptionText}>Поделиться GPX</Text>\n                        </TouchableOpacity>\n\n                        <TouchableOpacity\n                            style={styles.modalOption}\n                            onPress={() => {\n                                setExportMenuVisible(false);\n                                shareAsGeoJSON();\n                            }}\n                        >\n                            <Text style={styles.modalOptionText}>Поделиться GeoJSON</Text>\n                        </TouchableOpacity>\n\n                        <TouchableOpacity\n                            style={[styles.modalOption, styles.cancelOption]}\n                            onPress={() => setExportMenuVisible(false)}\n                        >\n                            <Text style={styles.cancelOptionText}>Отмена</Text>\n                        </TouchableOpacity>\n                    </View>\n                </TouchableOpacity>\n            </Modal>\n\n            <View ref={mapDivRef as any} style={styles.mapBox}>\n                <MapContainer\n                    bounds={bounds}\n                    style={styles.map}\n                    scrollWheelZoom={false}\n                    zoomControl={Platform.OS === 'web'}\n                    dragging={Platform.OS === 'web'}\n                    touchZoom={true}\n                    doubleClickZoom={false}\n                >\n                    <FitBounds />\n                    <TileLayer\n                        attribution=\"&copy; OpenStreetMap\"\n                        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n                    />\n\n                    {/* Линия по исходным точкам, чтобы сохранить порядок маршрута */}\n                    <Polyline\n                        positions={points.map(p => [p.lat, p.lng])}\n                        pathOptions={{ color: '#2563eb', weight: 4 }}\n                    />\n\n                    {/* Маркеры по сгруппированным координатам */}\n                    <FeatureGroup>\n                        {groupedPoints.map((gp, idx) => (\n                            <Marker\n                                key={`${gp.lat}-${gp.lng}-${idx}`}\n                                position={[gp.lat, gp.lng]}\n                                icon={numberIcon(L, gp.indexes.join(','), gp.indexes.includes(1))}\n                            >\n                                <Popup>\n                                    <View style={{ minWidth: 180 }}>\n                                        <Text style={styles.popupTitle}>\n                                            {gp.indexes.join(', ')}.\n                                        </Text>\n                                        <Text style={styles.popupCoords}>\n                                            {gp.lat.toFixed(6)}, {gp.lng.toFixed(6)}\n                                        </Text>\n                                        <Text style={[styles.popupCoords, { marginTop: 6 }]}>\n                                            {gp.titles.join(', ')}\n                                        </Text>\n                                    </View>\n                                </Popup>\n                            </Marker>\n                        ))}\n                    </FeatureGroup>\n                </MapContainer>\n            </View>\n\n            {/* Mobile touch hints */}\n            {Platform.OS !== 'web' && (\n                <View style={styles.touchHints}>\n                    <Text style={styles.hintText}>↕️ Двумя пальцами для масштабирования</Text>\n                </View>\n            )}\n        </View>\n    );\n}\n\nconst styles = StyleSheet.create({\n    wrap: {\n        width: '100%',\n        borderRadius: 16,\n        overflow: 'hidden',\n        borderWidth: 1,\n        borderColor: '#e5e7eb',\n        backgroundColor: '#fff',\n    },\n    toolbar: {\n        paddingHorizontal: 16,\n        paddingVertical: 12,\n        borderBottomWidth: 1,\n        borderBottomColor: '#e5e7eb',\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        backgroundColor: '#f8fafc',\n        minHeight: 60,\n    },\n    toolbarTitle: {\n        fontWeight: '800',\n        color: '#0f172a',\n        fontSize: 18,\n        flex: 1,\n        marginRight: 12,\n    },\n    webButtons: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 8,\n    },\n    btn: {\n        paddingHorizontal: 12,\n        paddingVertical: 8,\n        borderRadius: 8,\n        backgroundColor: '#0ea5e9',\n    },\n    btnTxt: {\n        color: '#fff',\n        fontWeight: '600',\n        fontSize: 12,\n    },\n    mobileMenuButton: {\n        padding: 8,\n        borderRadius: 8,\n        backgroundColor: '#0ea5e9',\n    },\n    mobileMenuText: {\n        color: '#fff',\n        fontWeight: 'bold',\n        fontSize: 18,\n    },\n    mapBox: {\n        flex: 1,\n        minHeight: 300,\n    },\n    map: {\n        width: '100%',\n        height: '100%',\n    },\n    loadingText: {\n        textAlign: 'center',\n        padding: 20,\n        color: '#64748b',\n    },\n    modalOverlay: {\n        flex: 1,\n        backgroundColor: 'rgba(0, 0, 0, 0.5)',\n        justifyContent: 'flex-end',\n    },\n    modalContent: {\n        backgroundColor: 'white',\n        borderTopLeftRadius: 20,\n        borderTopRightRadius: 20,\n        padding: 20,\n        paddingBottom: 30,\n    },\n    modalTitle: {\n        fontSize: 18,\n        fontWeight: 'bold',\n        textAlign: 'center',\n        marginBottom: 20,\n        color: '#0f172a',\n    },\n    modalOption: {\n        padding: 16,\n        borderBottomWidth: 1,\n        borderBottomColor: '#e5e7eb',\n    },\n    modalOptionText: {\n        fontSize: 16,\n        color: '#0f172a',\n        textAlign: 'center',\n    },\n    cancelOption: {\n        marginTop: 10,\n        backgroundColor: '#f1f5f9',\n        borderRadius: 12,\n        borderBottomWidth: 0,\n    },\n    cancelOptionText: {\n        fontSize: 16,\n        color: '#64748b',\n        fontWeight: '600',\n        textAlign: 'center',\n    },\n    popupTitle: {\n        fontWeight: 'bold',\n        fontSize: 14,\n        marginBottom: 4,\n        color: '#0f172a',\n    },\n    popupCoords: {\n        fontSize: 12,\n        color: '#64748b',\n    },\n    touchHints: {\n        padding: 12,\n        backgroundColor: '#f8fafc',\n        borderTopWidth: 1,\n        borderTopColor: '#e5e7eb',\n    },\n    hintText: {\n        fontSize: 12,\n        color: '#64748b',\n        textAlign: 'center',\n    },\n});\n","export * from './FileSystem';\nexport * from './FileSystem.types';\n","import { type EventSubscription, UnavailabilityError, uuid } from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\nimport ExponentFileSystem from './ExponentFileSystem';\nimport {\n  DownloadOptions,\n  DownloadPauseState,\n  FileSystemNetworkTaskProgressCallback,\n  DownloadProgressData,\n  UploadProgressData,\n  FileInfo,\n  FileSystemAcceptedUploadHttpMethod,\n  FileSystemDownloadResult,\n  FileSystemRequestDirectoryPermissionsResult,\n  FileSystemSessionType,\n  FileSystemUploadOptions,\n  FileSystemUploadResult,\n  FileSystemUploadType,\n  ProgressEvent,\n  ReadingOptions,\n  WritingOptions,\n  DeletingOptions,\n  InfoOptions,\n  RelocatingOptions,\n  MakeDirectoryOptions,\n} from './FileSystem.types';\n\nif (!ExponentFileSystem) {\n  console.warn(\n    \"No native ExponentFileSystem module found, are you sure the expo-file-system's module is linked properly?\"\n  );\n}\n\nfunction normalizeEndingSlash(p: string | null): string | null {\n  if (p != null) {\n    return p.replace(/\\/*$/, '') + '/';\n  }\n  return null;\n}\n\n/**\n * `file://` URI pointing to the directory where user documents for this app will be stored.\n * Files stored here will remain until explicitly deleted by the app. Ends with a trailing `/`.\n * Example uses are for files the user saves that they expect to see again.\n */\nexport const documentDirectory = normalizeEndingSlash(ExponentFileSystem.documentDirectory);\n\n/**\n * `file://` URI pointing to the directory where temporary files used by this app will be stored.\n * Files stored here may be automatically deleted by the system when low on storage.\n * Example uses are for downloaded or generated files that the app just needs for one-time usage.\n */\nexport const cacheDirectory = normalizeEndingSlash(ExponentFileSystem.cacheDirectory);\n\n/**\n * URI to the directory where assets bundled with the application are stored.\n */\nexport const bundleDirectory = normalizeEndingSlash(ExponentFileSystem.bundleDirectory);\n\n/**\n * Get metadata information about a file, directory or external content/asset.\n * @param fileUri URI to the file or directory. See [supported URI schemes](#supported-uri-schemes).\n * @param options A map of options represented by [`InfoOptions`](#infooptions) type.\n * @return A Promise that resolves to a `FileInfo` object. If no item exists at this URI,\n * the returned Promise resolves to `FileInfo` object in form of `{ exists: false, isDirectory: false }`.\n */\nexport async function getInfoAsync(fileUri: string, options: InfoOptions = {}): Promise<FileInfo> {\n  if (!ExponentFileSystem.getInfoAsync) {\n    throw new UnavailabilityError('expo-file-system', 'getInfoAsync');\n  }\n  return await ExponentFileSystem.getInfoAsync(fileUri, options);\n}\n\n/**\n * Read the entire contents of a file as a string. Binary will be returned in raw format, you will need to append `data:image/png;base64,` to use it as Base64.\n * @param fileUri `file://` or [SAF](#saf-uri) URI to the file or directory.\n * @param options A map of read options represented by [`ReadingOptions`](#readingoptions) type.\n * @return A Promise that resolves to a string containing the entire contents of the file.\n */\nexport async function readAsStringAsync(\n  fileUri: string,\n  options: ReadingOptions = {}\n): Promise<string> {\n  if (!ExponentFileSystem.readAsStringAsync) {\n    throw new UnavailabilityError('expo-file-system', 'readAsStringAsync');\n  }\n  return await ExponentFileSystem.readAsStringAsync(fileUri, options);\n}\n\n/**\n * Takes a `file://` URI and converts it into content URI (`content://`) so that it can be accessed by other applications outside of Expo.\n * @param fileUri The local URI of the file. If there is no file at this URI, an exception will be thrown.\n * @example\n * ```js\n * FileSystem.getContentUriAsync(uri).then(cUri => {\n *   console.log(cUri);\n *   IntentLauncher.startActivityAsync('android.intent.action.VIEW', {\n *     data: cUri,\n *     flags: 1,\n *   });\n * });\n * ```\n * @return Returns a Promise that resolves to a `string` containing a `content://` URI pointing to the file.\n * The URI is the same as the `fileUri` input parameter but in a different format.\n * @platform android\n */\nexport async function getContentUriAsync(fileUri: string): Promise<string> {\n  if (Platform.OS === 'android') {\n    if (!ExponentFileSystem.getContentUriAsync) {\n      throw new UnavailabilityError('expo-file-system', 'getContentUriAsync');\n    }\n    return await ExponentFileSystem.getContentUriAsync(fileUri);\n  } else {\n    return fileUri;\n  }\n}\n\n/**\n * Write the entire contents of a file as a string.\n * @param fileUri `file://` or [SAF](#saf-uri) URI to the file or directory.\n * > Note: when you're using SAF URI the file needs to exist. You can't create a new file.\n * @param contents The string to replace the contents of the file with.\n * @param options A map of write options represented by [`WritingOptions`](#writingoptions) type.\n */\nexport async function writeAsStringAsync(\n  fileUri: string,\n  contents: string,\n  options: WritingOptions = {}\n): Promise<void> {\n  if (!ExponentFileSystem.writeAsStringAsync) {\n    throw new UnavailabilityError('expo-file-system', 'writeAsStringAsync');\n  }\n  return await ExponentFileSystem.writeAsStringAsync(fileUri, contents, options);\n}\n\n/**\n * Delete a file or directory. If the URI points to a directory, the directory and all its contents are recursively deleted.\n * @param fileUri `file://` or [SAF](#saf-uri) URI to the file or directory.\n * @param options A map of write options represented by [`DeletingOptions`](#deletingoptions) type.\n */\nexport async function deleteAsync(fileUri: string, options: DeletingOptions = {}): Promise<void> {\n  if (!ExponentFileSystem.deleteAsync) {\n    throw new UnavailabilityError('expo-file-system', 'deleteAsync');\n  }\n  return await ExponentFileSystem.deleteAsync(fileUri, options);\n}\n\nexport async function deleteLegacyDocumentDirectoryAndroid(): Promise<void> {\n  if (Platform.OS !== 'android' || documentDirectory == null) {\n    return;\n  }\n  const legacyDocumentDirectory = `${documentDirectory}ExperienceData/`;\n  return await deleteAsync(legacyDocumentDirectory, { idempotent: true });\n}\n\n/**\n * Move a file or directory to a new location.\n * @param options A map of move options represented by [`RelocatingOptions`](#relocatingoptions) type.\n */\nexport async function moveAsync(options: RelocatingOptions): Promise<void> {\n  if (!ExponentFileSystem.moveAsync) {\n    throw new UnavailabilityError('expo-file-system', 'moveAsync');\n  }\n  return await ExponentFileSystem.moveAsync(options);\n}\n\n/**\n * Create a copy of a file or directory. Directories are recursively copied with all of their contents.\n * It can be also used to copy content shared by other apps to local filesystem.\n * @param options A map of move options represented by [`RelocatingOptions`](#relocatingoptions) type.\n */\nexport async function copyAsync(options: RelocatingOptions): Promise<void> {\n  if (!ExponentFileSystem.copyAsync) {\n    throw new UnavailabilityError('expo-file-system', 'copyAsync');\n  }\n  return await ExponentFileSystem.copyAsync(options);\n}\n\n/**\n * Create a new empty directory.\n * @param fileUri `file://` URI to the new directory to create.\n * @param options A map of create directory options represented by [`MakeDirectoryOptions`](#makedirectoryoptions) type.\n */\nexport async function makeDirectoryAsync(\n  fileUri: string,\n  options: MakeDirectoryOptions = {}\n): Promise<void> {\n  if (!ExponentFileSystem.makeDirectoryAsync) {\n    throw new UnavailabilityError('expo-file-system', 'makeDirectoryAsync');\n  }\n  return await ExponentFileSystem.makeDirectoryAsync(fileUri, options);\n}\n\n/**\n * Enumerate the contents of a directory.\n * @param fileUri `file://` URI to the directory.\n * @return A Promise that resolves to an array of strings, each containing the name of a file or directory contained in the directory at `fileUri`.\n */\nexport async function readDirectoryAsync(fileUri: string): Promise<string[]> {\n  if (!ExponentFileSystem.readDirectoryAsync) {\n    throw new UnavailabilityError('expo-file-system', 'readDirectoryAsync');\n  }\n  return await ExponentFileSystem.readDirectoryAsync(fileUri);\n}\n\n/**\n * Gets the available internal disk storage size, in bytes. This returns the free space on the data partition that hosts all of the internal storage for all apps on the device.\n * @return Returns a Promise that resolves to the number of bytes available on the internal disk.\n */\nexport async function getFreeDiskStorageAsync(): Promise<number> {\n  if (!ExponentFileSystem.getFreeDiskStorageAsync) {\n    throw new UnavailabilityError('expo-file-system', 'getFreeDiskStorageAsync');\n  }\n  return await ExponentFileSystem.getFreeDiskStorageAsync();\n}\n\n/**\n * Gets total internal disk storage size, in bytes. This is the total capacity of the data partition that hosts all the internal storage for all apps on the device.\n * @return Returns a Promise that resolves to a number that specifies the total internal disk storage capacity in bytes.\n */\nexport async function getTotalDiskCapacityAsync(): Promise<number> {\n  if (!ExponentFileSystem.getTotalDiskCapacityAsync) {\n    throw new UnavailabilityError('expo-file-system', 'getTotalDiskCapacityAsync');\n  }\n  return await ExponentFileSystem.getTotalDiskCapacityAsync();\n}\n\n/**\n * Download the contents at a remote URI to a file in the app's file system. The directory for a local file uri must exist prior to calling this function.\n * @param uri The remote URI to download from.\n * @param fileUri The local URI of the file to download to. If there is no file at this URI, a new one is created.\n * If there is a file at this URI, its contents are replaced. The directory for the file must exist.\n * @param options A map of download options represented by [`DownloadOptions`](#downloadoptions) type.\n * @example\n * ```js\n * FileSystem.downloadAsync(\n *   'http://techslides.com/demos/sample-videos/small.mp4',\n *   FileSystem.documentDirectory + 'small.mp4'\n * )\n *   .then(({ uri }) => {\n *     console.log('Finished downloading to ', uri);\n *   })\n *   .catch(error => {\n *     console.error(error);\n *   });\n * ```\n * @return Returns a Promise that resolves to a `FileSystemDownloadResult` object.\n */\nexport async function downloadAsync(\n  uri: string,\n  fileUri: string,\n  options: DownloadOptions = {}\n): Promise<FileSystemDownloadResult> {\n  if (!ExponentFileSystem.downloadAsync) {\n    throw new UnavailabilityError('expo-file-system', 'downloadAsync');\n  }\n\n  return await ExponentFileSystem.downloadAsync(uri, fileUri, {\n    sessionType: FileSystemSessionType.BACKGROUND,\n    ...options,\n  });\n}\n\n/**\n * Upload the contents of the file pointed by `fileUri` to the remote url.\n * @param url The remote URL, where the file will be sent.\n * @param fileUri The local URI of the file to send. The file must exist.\n * @param options A map of download options represented by [`FileSystemUploadOptions`](#filesystemuploadoptions) type.\n * @example\n * **Client**\n *\n * ```js\n * import * as FileSystem from 'expo-file-system';\n *\n * try {\n *   const response = await FileSystem.uploadAsync(`http://192.168.0.1:1234/binary-upload`, fileUri, {\n *     fieldName: 'file',\n *     httpMethod: 'PATCH',\n *     uploadType: FileSystem.FileSystemUploadType.BINARY_CONTENT,\n *   });\n *   console.log(JSON.stringify(response, null, 4));\n * } catch (error) {\n *   console.log(error);\n * }\n * ```\n *\n * **Server**\n *\n * Please refer to the \"[Server: Handling multipart requests](#server-handling-multipart-requests)\" example - there is code for a simple Node.js server.\n * @return Returns a Promise that resolves to `FileSystemUploadResult` object.\n */\nexport async function uploadAsync(\n  url: string,\n  fileUri: string,\n  options: FileSystemUploadOptions = {}\n): Promise<FileSystemUploadResult> {\n  if (!ExponentFileSystem.uploadAsync) {\n    throw new UnavailabilityError('expo-file-system', 'uploadAsync');\n  }\n\n  return await ExponentFileSystem.uploadAsync(url, fileUri, {\n    sessionType: FileSystemSessionType.BACKGROUND,\n    uploadType: FileSystemUploadType.BINARY_CONTENT,\n    ...options,\n    httpMethod: (options.httpMethod || 'POST').toUpperCase(),\n  });\n}\n\n/**\n * Create a `DownloadResumable` object which can start, pause, and resume a download of contents at a remote URI to a file in the app's file system.\n * > Note: You need to call `downloadAsync()`, on a `DownloadResumable` instance to initiate the download.\n * The `DownloadResumable` object has a callback that provides download progress updates.\n * Downloads can be resumed across app restarts by using `AsyncStorage` to store the `DownloadResumable.savable()` object for later retrieval.\n * The `savable` object contains the arguments required to initialize a new `DownloadResumable` object to resume the download after an app restart.\n * The directory for a local file uri must exist prior to calling this function.\n * @param uri The remote URI to download from.\n * @param fileUri The local URI of the file to download to. If there is no file at this URI, a new one is created.\n * If there is a file at this URI, its contents are replaced. The directory for the file must exist.\n * @param options A map of download options represented by [`DownloadOptions`](#downloadoptions) type.\n * @param callback This function is called on each data write to update the download progress.\n * > **Note**: When the app has been moved to the background, this callback won't be fired until it's moved to the foreground.\n * @param resumeData The string which allows the api to resume a paused download. This is set on the `DownloadResumable` object automatically when a download is paused.\n * When initializing a new `DownloadResumable` this should be `null`.\n */\nexport function createDownloadResumable(\n  uri: string,\n  fileUri: string,\n  options?: DownloadOptions,\n  callback?: FileSystemNetworkTaskProgressCallback<DownloadProgressData>,\n  resumeData?: string\n): DownloadResumable {\n  return new DownloadResumable(uri, fileUri, options, callback, resumeData);\n}\n\nexport function createUploadTask(\n  url: string,\n  fileUri: string,\n  options?: FileSystemUploadOptions,\n  callback?: FileSystemNetworkTaskProgressCallback<UploadProgressData>\n): UploadTask {\n  return new UploadTask(url, fileUri, options, callback);\n}\n\nexport abstract class FileSystemCancellableNetworkTask<\n  T extends DownloadProgressData | UploadProgressData,\n> {\n  private _uuid = uuid.v4();\n  protected taskWasCanceled = false;\n  private subscription?: EventSubscription | null;\n\n  // @docsMissing\n  public async cancelAsync(): Promise<void> {\n    if (!ExponentFileSystem.networkTaskCancelAsync) {\n      throw new UnavailabilityError('expo-file-system', 'networkTaskCancelAsync');\n    }\n\n    this.removeSubscription();\n    this.taskWasCanceled = true;\n    return await ExponentFileSystem.networkTaskCancelAsync(this.uuid);\n  }\n\n  protected isTaskCancelled(): boolean {\n    if (this.taskWasCanceled) {\n      console.warn('This task was already canceled.');\n      return true;\n    }\n\n    return false;\n  }\n\n  protected get uuid(): string {\n    return this._uuid;\n  }\n\n  protected abstract getEventName(): string;\n\n  protected abstract getCallback(): FileSystemNetworkTaskProgressCallback<T> | undefined;\n\n  protected addSubscription() {\n    if (this.subscription) {\n      return;\n    }\n\n    this.subscription = ExponentFileSystem.addListener(\n      this.getEventName(),\n      (event: ProgressEvent<T>) => {\n        if (event.uuid === this.uuid) {\n          const callback = this.getCallback();\n          if (callback) {\n            callback(event.data as T);\n          }\n        }\n      }\n    );\n  }\n\n  protected removeSubscription() {\n    if (!this.subscription) {\n      return;\n    }\n    this.subscription.remove();\n    this.subscription = null;\n  }\n}\n\nexport class UploadTask extends FileSystemCancellableNetworkTask<UploadProgressData> {\n  private options: FileSystemUploadOptions;\n\n  constructor(\n    private url: string,\n    private fileUri: string,\n    options?: FileSystemUploadOptions,\n    private callback?: FileSystemNetworkTaskProgressCallback<UploadProgressData>\n  ) {\n    super();\n\n    const httpMethod = (options?.httpMethod?.toUpperCase() ||\n      'POST') as FileSystemAcceptedUploadHttpMethod;\n\n    this.options = {\n      sessionType: FileSystemSessionType.BACKGROUND,\n      uploadType: FileSystemUploadType.BINARY_CONTENT,\n      ...options,\n      httpMethod,\n    };\n  }\n\n  protected getEventName(): string {\n    return 'expo-file-system.uploadProgress';\n  }\n  protected getCallback(): FileSystemNetworkTaskProgressCallback<UploadProgressData> | undefined {\n    return this.callback;\n  }\n\n  // @docsMissing\n  public async uploadAsync(): Promise<FileSystemUploadResult | undefined> {\n    if (!ExponentFileSystem.uploadTaskStartAsync) {\n      throw new UnavailabilityError('expo-file-system', 'uploadTaskStartAsync');\n    }\n\n    if (this.isTaskCancelled()) {\n      return;\n    }\n\n    this.addSubscription();\n    const result = await ExponentFileSystem.uploadTaskStartAsync(\n      this.url,\n      this.fileUri,\n      this.uuid,\n      this.options\n    );\n    this.removeSubscription();\n\n    return result;\n  }\n}\n\nexport class DownloadResumable extends FileSystemCancellableNetworkTask<DownloadProgressData> {\n  constructor(\n    private url: string,\n    private _fileUri: string,\n    private options: DownloadOptions = {},\n    private callback?: FileSystemNetworkTaskProgressCallback<DownloadProgressData>,\n    private resumeData?: string\n  ) {\n    super();\n  }\n\n  public get fileUri(): string {\n    return this._fileUri;\n  }\n\n  protected getEventName(): string {\n    return 'expo-file-system.downloadProgress';\n  }\n\n  protected getCallback(): FileSystemNetworkTaskProgressCallback<DownloadProgressData> | undefined {\n    return this.callback;\n  }\n\n  /**\n   * Download the contents at a remote URI to a file in the app's file system.\n   * @return Returns a Promise that resolves to `FileSystemDownloadResult` object, or to `undefined` when task was cancelled.\n   */\n  async downloadAsync(): Promise<FileSystemDownloadResult | undefined> {\n    if (!ExponentFileSystem.downloadResumableStartAsync) {\n      throw new UnavailabilityError('expo-file-system', 'downloadResumableStartAsync');\n    }\n\n    if (this.isTaskCancelled()) {\n      return;\n    }\n\n    this.addSubscription();\n    return await ExponentFileSystem.downloadResumableStartAsync(\n      this.url,\n      this._fileUri,\n      this.uuid,\n      this.options,\n      this.resumeData\n    );\n  }\n\n  /**\n   * Pause the current download operation. `resumeData` is added to the `DownloadResumable` object after a successful pause operation.\n   * Returns an object that can be saved with `AsyncStorage` for future retrieval (the same object that is returned from calling `FileSystem.DownloadResumable.savable()`).\n   * @return Returns a Promise that resolves to `DownloadPauseState` object.\n   */\n  async pauseAsync(): Promise<DownloadPauseState> {\n    if (!ExponentFileSystem.downloadResumablePauseAsync) {\n      throw new UnavailabilityError('expo-file-system', 'downloadResumablePauseAsync');\n    }\n\n    if (this.isTaskCancelled()) {\n      return {\n        fileUri: this._fileUri,\n        options: this.options,\n        url: this.url,\n      };\n    }\n\n    const pauseResult = await ExponentFileSystem.downloadResumablePauseAsync(this.uuid);\n    this.removeSubscription();\n    if (pauseResult) {\n      this.resumeData = pauseResult.resumeData;\n      return this.savable();\n    } else {\n      throw new Error('Unable to generate a savable pause state');\n    }\n  }\n\n  /**\n   * Resume a paused download operation.\n   * @return Returns a Promise that resolves to `FileSystemDownloadResult` object, or to `undefined` when task was cancelled.\n   */\n  async resumeAsync(): Promise<FileSystemDownloadResult | undefined> {\n    if (!ExponentFileSystem.downloadResumableStartAsync) {\n      throw new UnavailabilityError('expo-file-system', 'downloadResumableStartAsync');\n    }\n\n    if (this.isTaskCancelled()) {\n      return;\n    }\n\n    this.addSubscription();\n    return await ExponentFileSystem.downloadResumableStartAsync(\n      this.url,\n      this.fileUri,\n      this.uuid,\n      this.options,\n      this.resumeData\n    );\n  }\n\n  /**\n   * Method to get the object which can be saved with `AsyncStorage` for future retrieval.\n   * @returns Returns object in shape of `DownloadPauseState` type.\n   */\n  savable(): DownloadPauseState {\n    return {\n      url: this.url,\n      fileUri: this.fileUri,\n      options: this.options,\n      resumeData: this.resumeData,\n    };\n  }\n}\n\nconst baseReadAsStringAsync = readAsStringAsync;\nconst baseWriteAsStringAsync = writeAsStringAsync;\nconst baseDeleteAsync = deleteAsync;\nconst baseMoveAsync = moveAsync;\nconst baseCopyAsync = copyAsync;\n\n/**\n * The `StorageAccessFramework` is a namespace inside of the `expo-file-system` module, which encapsulates all functions which can be used with [SAF URIs](#saf-uri).\n * You can read more about SAF in the [Android documentation](https://developer.android.com/guide/topics/providers/document-provider).\n *\n * @example\n * # Basic Usage\n *\n * ```ts\n * import { StorageAccessFramework } from 'expo-file-system';\n *\n * // Requests permissions for external directory\n * const permissions = await StorageAccessFramework.requestDirectoryPermissionsAsync();\n *\n * if (permissions.granted) {\n *   // Gets SAF URI from response\n *   const uri = permissions.directoryUri;\n *\n *   // Gets all files inside of selected directory\n *   const files = await StorageAccessFramework.readDirectoryAsync(uri);\n *   alert(`Files inside ${uri}:\\n\\n${JSON.stringify(files)}`);\n * }\n * ```\n *\n * # Migrating an album\n *\n * ```ts\n * import * as MediaLibrary from 'expo-media-library';\n * import * as FileSystem from 'expo-file-system';\n * const { StorageAccessFramework } = FileSystem;\n *\n * async function migrateAlbum(albumName: string) {\n *   // Gets SAF URI to the album\n *   const albumUri = StorageAccessFramework.getUriForDirectoryInRoot(albumName);\n *\n *   // Requests permissions\n *   const permissions = await StorageAccessFramework.requestDirectoryPermissionsAsync(albumUri);\n *   if (!permissions.granted) {\n *     return;\n *   }\n *\n *   const permittedUri = permissions.directoryUri;\n *   // Checks if users selected the correct folder\n *   if (!permittedUri.includes(albumName)) {\n *     return;\n *   }\n *\n *   const mediaLibraryPermissions = await MediaLibrary.requestPermissionsAsync();\n *   if (!mediaLibraryPermissions.granted) {\n *     return;\n *   }\n *\n *   // Moves files from external storage to internal storage\n *   await StorageAccessFramework.moveAsync({\n *     from: permittedUri,\n *     to: FileSystem.documentDirectory!,\n *   });\n *\n *   const outputDir = FileSystem.documentDirectory! + albumName;\n *   const migratedFiles = await FileSystem.readDirectoryAsync(outputDir);\n *\n *   // Creates assets from local files\n *   const [newAlbumCreator, ...assets] = await Promise.all(\n *     migratedFiles.map<Promise<MediaLibrary.Asset>>(\n *       async fileName => await MediaLibrary.createAssetAsync(outputDir + '/' + fileName)\n *     )\n *   );\n *\n *   // Album was empty\n *   if (!newAlbumCreator) {\n *     return;\n *   }\n *\n *   // Creates a new album in the scoped directory\n *   const newAlbum = await MediaLibrary.createAlbumAsync(albumName, newAlbumCreator, false);\n *   if (assets.length) {\n *     await MediaLibrary.addAssetsToAlbumAsync(assets, newAlbum, false);\n *   }\n * }\n * ```\n * @platform Android\n */\nexport namespace StorageAccessFramework {\n  /**\n   * Gets a [SAF URI](#saf-uri) pointing to a folder in the Android root directory. You can use this function to get URI for\n   * `StorageAccessFramework.requestDirectoryPermissionsAsync()` when you trying to migrate an album. In that case, the name of the album is the folder name.\n   * @param folderName The name of the folder which is located in the Android root directory.\n   * @return Returns a [SAF URI](#saf-uri) to a folder.\n   */\n  export function getUriForDirectoryInRoot(folderName: string) {\n    return `content://com.android.externalstorage.documents/tree/primary:${folderName}/document/primary:${folderName}`;\n  }\n\n  /**\n   * Allows users to select a specific directory, granting your app access to all of the files and sub-directories within that directory.\n   * @param initialFileUrl The [SAF URI](#saf-uri) of the directory that the file picker should display when it first loads.\n   * If URI is incorrect or points to a non-existing folder, it's ignored.\n   * @platform android 11+\n   * @return Returns a Promise that resolves to `FileSystemRequestDirectoryPermissionsResult` object.\n   */\n  export async function requestDirectoryPermissionsAsync(\n    initialFileUrl: string | null = null\n  ): Promise<FileSystemRequestDirectoryPermissionsResult> {\n    if (!ExponentFileSystem.requestDirectoryPermissionsAsync) {\n      throw new UnavailabilityError(\n        'expo-file-system',\n        'StorageAccessFramework.requestDirectoryPermissionsAsync'\n      );\n    }\n\n    return await ExponentFileSystem.requestDirectoryPermissionsAsync(initialFileUrl);\n  }\n\n  /**\n   * Enumerate the contents of a directory.\n   * @param dirUri [SAF](#saf-uri) URI to the directory.\n   * @return A Promise that resolves to an array of strings, each containing the full [SAF URI](#saf-uri) of a file or directory contained in the directory at `fileUri`.\n   */\n  export async function readDirectoryAsync(dirUri: string): Promise<string[]> {\n    if (!ExponentFileSystem.readSAFDirectoryAsync) {\n      throw new UnavailabilityError(\n        'expo-file-system',\n        'StorageAccessFramework.readDirectoryAsync'\n      );\n    }\n    return await ExponentFileSystem.readSAFDirectoryAsync(dirUri);\n  }\n\n  /**\n   * Creates a new empty directory.\n   * @param parentUri The [SAF](#saf-uri) URI to the parent directory.\n   * @param dirName The name of new directory.\n   * @return A Promise that resolves to a [SAF URI](#saf-uri) to the created directory.\n   */\n  export async function makeDirectoryAsync(parentUri: string, dirName: string): Promise<string> {\n    if (!ExponentFileSystem.makeSAFDirectoryAsync) {\n      throw new UnavailabilityError(\n        'expo-file-system',\n        'StorageAccessFramework.makeDirectoryAsync'\n      );\n    }\n    return await ExponentFileSystem.makeSAFDirectoryAsync(parentUri, dirName);\n  }\n\n  /**\n   * Creates a new empty file.\n   * @param parentUri The [SAF](#saf-uri) URI to the parent directory.\n   * @param fileName The name of new file **without the extension**.\n   * @param mimeType The MIME type of new file.\n   * @return A Promise that resolves to a [SAF URI](#saf-uri) to the created file.\n   */\n  export async function createFileAsync(\n    parentUri: string,\n    fileName: string,\n    mimeType: string\n  ): Promise<string> {\n    if (!ExponentFileSystem.createSAFFileAsync) {\n      throw new UnavailabilityError('expo-file-system', 'StorageAccessFramework.createFileAsync');\n    }\n    return await ExponentFileSystem.createSAFFileAsync(parentUri, fileName, mimeType);\n  }\n\n  /**\n   * Alias for [`writeAsStringAsync`](#filesystemwriteasstringasyncfileuri-contents-options) method.\n   */\n  export const writeAsStringAsync = baseWriteAsStringAsync;\n  /**\n   * Alias for [`readAsStringAsync`](#filesystemreadasstringasyncfileuri-options) method.\n   */\n  export const readAsStringAsync = baseReadAsStringAsync;\n  /**\n   * Alias for [`deleteAsync`](#filesystemdeleteasyncfileuri-options) method.\n   */\n  export const deleteAsync = baseDeleteAsync;\n  /**\n   * Alias for [`moveAsync`](#filesystemmoveasyncoptions) method.\n   */\n  export const moveAsync = baseMoveAsync;\n  /**\n   * Alias for [`copyAsync`](#filesystemcopyasyncoptions) method.\n   */\n  export const copyAsync = baseCopyAsync;\n}\n","import ExponentFileSystemShim from './ExponentFileSystemShim';\nexport default ExponentFileSystemShim;\n","import { NativeModule } from 'expo-modules-core';\n\nimport type { ExponentFileSystemModule, FileSystemEvents } from './types';\n\nexport default class FileSystemShim\n  extends NativeModule<FileSystemEvents>\n  implements ExponentFileSystemModule\n{\n  documentDirectory = null;\n  cacheDirectory = null;\n  bundleDirectory = null;\n}\n","/**\n * These values can be used to define how sessions work on iOS.\n * @platform ios\n */\nexport enum FileSystemSessionType {\n  /**\n   * Using this mode means that the downloading/uploading session on the native side will work even if the application is moved to background.\n   * If the task completes while the application is in background, the Promise will be either resolved immediately or (if the application execution has already been stopped) once the app is moved to foreground again.\n   * > Note: The background session doesn't fail if the server or your connection is down. Rather, it continues retrying until the task succeeds or is canceled manually.\n   */\n  BACKGROUND = 0,\n  /**\n   * Using this mode means that downloading/uploading session on the native side will be terminated once the application becomes inactive (e.g. when it goes to background).\n   * Bringing the application to foreground again would trigger Promise rejection.\n   */\n  FOREGROUND = 1,\n}\n\nexport enum FileSystemUploadType {\n  /**\n   * The file will be sent as a request's body. The request can't contain additional data.\n   */\n  BINARY_CONTENT = 0,\n  /**\n   * An [RFC 2387-compliant](https://www.ietf.org/rfc/rfc2387.txt) request body. The provided file will be encoded into HTTP request.\n   * This request can contain additional data represented by [`UploadOptionsMultipart`](#uploadoptionsmultipart) type.\n   */\n  MULTIPART = 1,\n}\n\nexport type DownloadOptions = {\n  /**\n   * If `true`, include the MD5 hash of the file in the returned object. Provided for convenience since it is common to check the integrity of a file immediately after downloading.\n   * @default false\n   */\n  md5?: boolean;\n  // @docsMissing\n  cache?: boolean;\n  /**\n   * An object containing all the HTTP header fields and their values for the download network request. The keys and values of the object are the header names and values respectively.\n   */\n  headers?: Record<string, string>;\n  /**\n   * A session type. Determines if tasks can be handled in the background. On Android, sessions always work in the background and you can't change it.\n   * @default FileSystemSessionType.BACKGROUND\n   * @platform ios\n   */\n  sessionType?: FileSystemSessionType;\n};\n\nexport type FileSystemHttpResult = {\n  /**\n   * An object containing all the HTTP response header fields and their values for the download network request.\n   * The keys and values of the object are the header names and values respectively.\n   */\n  headers: Record<string, string>;\n  /**\n   * The HTTP response status code for the download network request.\n   */\n  status: number;\n  // @docsMissing\n  mimeType: string | null;\n};\n\nexport type FileSystemDownloadResult = FileSystemHttpResult & {\n  /**\n   * A `file://` URI pointing to the file. This is the same as the `fileUri` input parameter.\n   */\n  uri: string;\n  /**\n   * Present if the `md5` option was truthy. Contains the MD5 hash of the file.\n   */\n  md5?: string;\n};\n\n/**\n * @deprecated Use `FileSystemDownloadResult` instead.\n */\nexport type DownloadResult = FileSystemDownloadResult;\n\nexport type FileSystemUploadOptions = (UploadOptionsBinary | UploadOptionsMultipart) & {\n  /**\n   * An object containing all the HTTP header fields and their values for the upload network request.\n   * The keys and values of the object are the header names and values respectively.\n   */\n  headers?: Record<string, string>;\n  /**\n   * The request method.\n   * @default FileSystemAcceptedUploadHttpMethod.POST\n   */\n  httpMethod?: FileSystemAcceptedUploadHttpMethod;\n  /**\n   * A session type. Determines if tasks can be handled in the background. On Android, sessions always work in the background and you can't change it.\n   * @default FileSystemSessionType.BACKGROUND\n   * @platform ios\n   */\n  sessionType?: FileSystemSessionType;\n};\n\n/**\n * Upload options when upload type is set to binary.\n */\nexport type UploadOptionsBinary = {\n  /**\n   * Upload type determines how the file will be sent to the server.\n   * Value will be `FileSystemUploadType.BINARY_CONTENT`.\n   */\n  uploadType?: FileSystemUploadType;\n};\n\n/**\n * Upload options when upload type is set to multipart.\n */\nexport type UploadOptionsMultipart = {\n  /**\n   * Upload type determines how the file will be sent to the server.\n   * Value will be `FileSystemUploadType.MULTIPART`.\n   */\n  uploadType: FileSystemUploadType;\n  /**\n   * The name of the field which will hold uploaded file. Defaults to the file name without an extension.\n   */\n  fieldName?: string;\n  /**\n   * The MIME type of the provided file. If not provided, the module will try to guess it based on the extension.\n   */\n  mimeType?: string;\n  /**\n   * Additional form properties. They will be located in the request body.\n   */\n  parameters?: Record<string, string>;\n};\n\nexport type FileSystemUploadResult = FileSystemHttpResult & {\n  /**\n   * The body of the server response.\n   */\n  body: string;\n};\n\n// @docsMissing\nexport type FileSystemNetworkTaskProgressCallback<\n  T extends DownloadProgressData | UploadProgressData,\n> = (data: T) => void;\n\n/**\n * @deprecated use `FileSystemNetworkTaskProgressCallback<DownloadProgressData>` instead.\n */\nexport type DownloadProgressCallback = FileSystemNetworkTaskProgressCallback<DownloadProgressData>;\n\nexport type DownloadProgressData = {\n  /**\n   * The total bytes written by the download operation.\n   */\n  totalBytesWritten: number;\n  /**\n   * The total bytes expected to be written by the download operation. A value of `-1` means that the server did not return the `Content-Length` header\n   * and the total size is unknown. Without this header, you won't be able to track the download progress.\n   */\n  totalBytesExpectedToWrite: number;\n};\n\nexport type UploadProgressData = {\n  /**\n   * The total bytes sent by the upload operation.\n   */\n  totalBytesSent: number;\n  /**\n   * The total bytes expected to be sent by the upload operation.\n   */\n  totalBytesExpectedToSend: number;\n};\n\nexport type DownloadPauseState = {\n  /**\n   * The remote URI to download from.\n   */\n  url: string;\n  /**\n   * The local URI of the file to download to. If there is no file at this URI, a new one is created. If there is a file at this URI, its contents are replaced.\n   */\n  fileUri: string;\n  /**\n   * Object representing the file download options.\n   */\n  options: DownloadOptions;\n  /**\n   * The string which allows the API to resume a paused download.\n   */\n  resumeData?: string;\n};\n\nexport type FileInfo =\n  /**\n   * Object returned when file exist.\n   */\n  | {\n      /**\n       * Signifies that the requested file exist.\n       */\n      exists: true;\n      /**\n       * A `file://` URI pointing to the file. This is the same as the `fileUri` input parameter.\n       */\n      uri: string;\n      /**\n       * The size of the file in bytes. If operating on a source such as an iCloud file, only present if the `size` option was truthy.\n       */\n      size: number;\n      /**\n       * Boolean set to `true` if this is a directory and `false` if it is a file.\n       */\n      isDirectory: boolean;\n      /**\n       * The last modification time of the file expressed in seconds since epoch.\n       */\n      modificationTime: number;\n      /**\n       * Present if the `md5` option was truthy. Contains the MD5 hash of the file.\n       */\n      md5?: string;\n    }\n  /**\n   * Object returned when file do not exist.\n   */\n  | {\n      exists: false;\n      uri: string;\n      isDirectory: false;\n    };\n\n/**\n * These values can be used to define how file system data is read / written.\n */\nexport enum EncodingType {\n  /**\n   * Standard encoding format.\n   */\n  UTF8 = 'utf8',\n  /**\n   * Binary, radix-64 representation.\n   */\n  Base64 = 'base64',\n}\n\n// @docsMissing\nexport type FileSystemAcceptedUploadHttpMethod = 'POST' | 'PUT' | 'PATCH';\n\nexport type ReadingOptions = {\n  /**\n   * The encoding format to use when reading the file.\n   * @default EncodingType.UTF8\n   */\n  encoding?: EncodingType | 'utf8' | 'base64';\n  /**\n   * Optional number of bytes to skip. This option is only used when `encoding: FileSystem.EncodingType.Base64` and `length` is defined.\n   * */\n  position?: number;\n  /**\n   * Optional number of bytes to read. This option is only used when `encoding: FileSystem.EncodingType.Base64` and `position` is defined.\n   */\n  length?: number;\n};\n\nexport type WritingOptions = {\n  /**\n   * The encoding format to use when writing the file.\n   * @default FileSystem.EncodingType.UTF8\n   */\n  encoding?: EncodingType | 'utf8' | 'base64';\n};\n\nexport type DeletingOptions = {\n  /**\n   * If `true`, don't throw an error if there is no file or directory at this URI.\n   * @default false\n   */\n  idempotent?: boolean;\n};\n\nexport type InfoOptions = {\n  /**\n   * Whether to return the MD5 hash of the file.\n   * @default false\n   */\n  md5?: boolean;\n  /**\n   * Explicitly specify that the file size should be included. For example, skipping this can prevent downloading the file if it's stored in iCloud.\n   * The size is always returned for `file://` locations.\n   */\n  size?: boolean;\n};\n\nexport type RelocatingOptions = {\n  /**\n   * URI or [SAF](#saf-uri) URI to the asset, file, or directory. See [supported URI schemes](#supported-uri-schemes-1).\n   */\n  from: string;\n  /**\n   * `file://` URI to the file or directory which should be its new location.\n   */\n  to: string;\n};\n\nexport type MakeDirectoryOptions = {\n  /**\n   * If `true`, don't throw an error if there is no file or directory at this URI.\n   * @default false\n   */\n  intermediates?: boolean;\n};\n\n// @docsMissing\nexport type ProgressEvent<T> = {\n  uuid: string;\n  data: T;\n};\n\nexport type FileSystemRequestDirectoryPermissionsResult =\n  /**\n   * If the permissions were not granted.\n   */\n  | {\n      granted: false;\n    }\n  /**\n   * If the permissions were granted.\n   */\n  | {\n      granted: true;\n      /**\n       * The [SAF URI](#saf-uri) to the user's selected directory. Available only if permissions were granted.\n       */\n      directoryUri: string;\n    };\n","import { UnavailabilityError } from 'expo-modules-core';\nimport Sharing from './ExpoSharing';\n// @needsAudit\n/**\n * Determine if the sharing API can be used in this app.\n * @return A promise that fulfills with `true` if the sharing API can be used, and `false` otherwise.\n */\nexport async function isAvailableAsync() {\n    if (Sharing) {\n        if (Sharing.isAvailableAsync) {\n            return await Sharing.isAvailableAsync();\n        }\n        return true;\n    }\n    return false;\n}\n// @needsAudit\n/**\n * Opens action sheet to share file to different applications which can handle this type of file.\n * @param url Local file URL to share.\n * @param options A map of share options.\n */\nexport async function shareAsync(url, options = {}) {\n    if (!Sharing || !Sharing.shareAsync) {\n        throw new UnavailabilityError('Sharing', 'shareAsync');\n    }\n    return await Sharing.shareAsync(url, options);\n}\n//# sourceMappingURL=Sharing.js.map","import { UnavailabilityError } from 'expo-modules-core';\nexport default {\n    async isAvailableAsync() {\n        if (typeof navigator === 'undefined') {\n            return false;\n        }\n        return !!navigator.share;\n    },\n    async shareAsync(url, options = {}) {\n        // NOTE: `navigator.share` is only available via HTTPS\n        if (navigator.share) {\n            await navigator.share({ ...options, url });\n        }\n        else {\n            throw new UnavailabilityError('navigator', 'share');\n        }\n    },\n};\n//# sourceMappingURL=ExpoSharing.web.js.map","import { PermissionStatus, createPermissionHook, UnavailabilityError, } from 'expo-modules-core';\nimport { Platform } from 'react-native';\nimport MediaLibrary from './ExpoMediaLibrary';\nconst isExpoGo = typeof expo !== 'undefined' && globalThis.expo?.modules?.ExpoGo;\nlet loggedExpoGoWarning = false;\nif (isExpoGo && !loggedExpoGoWarning) {\n    console.warn('Due to changes in Androids permission requirements, Expo Go can no longer provide full access to the media library. To test the full functionality of this module, you can create a development build. https://docs.expo.dev/develop/development-builds/create-a-build');\n    loggedExpoGoWarning = true;\n}\nexport { PermissionStatus, };\nfunction arrayize(item) {\n    if (Array.isArray(item)) {\n        return item;\n    }\n    return item ? [item] : [];\n}\nfunction getId(ref) {\n    if (typeof ref === 'string') {\n        return ref;\n    }\n    return ref ? ref.id : undefined;\n}\nfunction checkAssetIds(assetIds) {\n    if (assetIds.some((id) => !id || typeof id !== 'string')) {\n        throw new Error('Asset ID must be a string!');\n    }\n}\nfunction checkAlbumIds(albumIds) {\n    if (albumIds.some((id) => !id || typeof id !== 'string')) {\n        throw new Error('Album ID must be a string!');\n    }\n}\nfunction checkMediaType(mediaType) {\n    if (Object.values(MediaType).indexOf(mediaType) === -1) {\n        throw new Error(`Invalid mediaType: ${mediaType}`);\n    }\n}\nfunction checkSortBy(sortBy) {\n    if (Array.isArray(sortBy)) {\n        checkSortByKey(sortBy[0]);\n        if (typeof sortBy[1] !== 'boolean') {\n            throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n        }\n    }\n    else {\n        checkSortByKey(sortBy);\n    }\n}\nfunction checkSortByKey(sortBy) {\n    if (Object.values(SortBy).indexOf(sortBy) === -1) {\n        throw new Error(`Invalid sortBy key: ${sortBy}`);\n    }\n}\nfunction sortByOptionToString(sortBy) {\n    if (Array.isArray(sortBy)) {\n        return `${sortBy[0]} ${sortBy[1] ? 'ASC' : 'DESC'}`;\n    }\n    return `${sortBy} DESC`;\n}\nfunction dateToNumber(value) {\n    return value instanceof Date ? value.getTime() : value;\n}\n// @needsAudit\n/**\n * Possible media types.\n */\nexport const MediaType = MediaLibrary.MediaType;\n// @needsAudit\n/**\n * Supported keys that can be used to sort `getAssetsAsync` results.\n */\nexport const SortBy = MediaLibrary.SortBy;\n// @needsAudit\n/**\n * Returns whether the Media Library API is enabled on the current device.\n * @return A promise which fulfils with a `boolean`, indicating whether the Media Library API is\n * available on the current device.\n */\nexport async function isAvailableAsync() {\n    return !!MediaLibrary && 'getAssetsAsync' in MediaLibrary;\n}\n// @needsAudit @docsMissing\n/**\n * Asks the user to grant permissions for accessing media in user's media library.\n * @param writeOnly\n * @param granularPermissions - A list of [`GranularPermission`](#granularpermission) values. This parameter has an\n * effect only on Android 13 and newer. By default, `expo-media-library` will ask for all possible permissions.\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function requestPermissionsAsync(writeOnly = false, granularPermissions) {\n    if (!MediaLibrary.requestPermissionsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n    }\n    if (Platform.OS === 'android') {\n        return await MediaLibrary.requestPermissionsAsync(writeOnly, granularPermissions);\n    }\n    return await MediaLibrary.requestPermissionsAsync(writeOnly);\n}\n// @needsAudit @docsMissing\n/**\n * Checks user's permissions for accessing media library.\n * @param writeOnly\n * @param granularPermissions - A list of [`GranularPermission`](#granularpermission) values. This parameter has\n * an effect only on Android 13 and newer. By default, `expo-media-library` will ask for all possible permissions.\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function getPermissionsAsync(writeOnly = false, granularPermissions) {\n    if (!MediaLibrary.getPermissionsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n    }\n    if (Platform.OS === 'android') {\n        return await MediaLibrary.getPermissionsAsync(writeOnly, granularPermissions);\n    }\n    return await MediaLibrary.getPermissionsAsync(writeOnly);\n}\n// @needsAudit\n/**\n * Check or request permissions to access the media library.\n * This uses both `requestPermissionsAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = MediaLibrary.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n    // TODO(cedric): permission requesters should have an options param or a different requester\n    getMethod: (options) => getPermissionsAsync(options?.writeOnly, options?.granularPermissions),\n    requestMethod: (options) => requestPermissionsAsync(options?.writeOnly, options?.granularPermissions),\n});\n// @needsAudit\n/**\n * Allows the user to update the assets that your app has access to.\n * The system modal is only displayed if the user originally allowed only `limited` access to their\n * media library, otherwise this method is a no-op.\n * @param mediaTypes Limits the type(s) of media that the user will be granting access to. By default, a list that shows both photos and videos is presented.\n *\n * @return A promise that either rejects if the method is unavailable, or resolves to `void`.\n * > __Note:__ This method doesn't inform you if the user changes which assets your app has access to.\n * That information is only exposed by iOS, and to obtain it, you need to subscribe for updates to the user's media library using [`addListener()`](#medialibraryaddlistenerlistener).\n * If `hasIncrementalChanges` is `false`, the user changed their permissions.\n *\n * @platform android 14+\n * @platform ios\n */\nexport async function presentPermissionsPickerAsync(mediaTypes = ['photo', 'video']) {\n    if (Platform.OS === 'android' && isExpoGo) {\n        throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync is unavailable in Expo Go');\n    }\n    if (Platform.OS === 'android' && Platform.Version >= 34) {\n        await MediaLibrary.requestPermissionsAsync(false, mediaTypes);\n        return;\n    }\n    if (!MediaLibrary.presentPermissionsPickerAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n    }\n    return await MediaLibrary.presentPermissionsPickerAsync();\n}\n// @needsAudit\n/**\n * Creates an asset from existing file. The most common use case is to save a picture taken by [Camera](./camera).\n * This method requires `CAMERA_ROLL` permission.\n *\n * @example\n * ```js\n * const { uri } = await Camera.takePictureAsync();\n * const asset = await MediaLibrary.createAssetAsync(uri);\n * ```\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`\n * @return A promise which fulfils with an object representing an [`Asset`](#asset).\n */\nexport async function createAssetAsync(localUri) {\n    if (!MediaLibrary.createAssetAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'createAssetAsync');\n    }\n    if (!localUri || typeof localUri !== 'string') {\n        throw new Error('Invalid argument \"localUri\". It must be a string!');\n    }\n    const asset = await MediaLibrary.createAssetAsync(localUri);\n    if (Array.isArray(asset)) {\n        // Android returns an array with asset, we need to pick the first item\n        return asset[0];\n    }\n    return asset;\n}\n// @needsAudit\n/**\n * Saves the file at given `localUri` to the user's media library. Unlike [`createAssetAsync()`](#medialibrarycreateassetasynclocaluri),\n * This method doesn't return created asset.\n * On __iOS 11+__, it's possible to use this method without asking for `CAMERA_ROLL` permission,\n * however then yours `Info.plist` should have `NSPhotoLibraryAddUsageDescription` key.\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`.\n */\nexport async function saveToLibraryAsync(localUri) {\n    if (!MediaLibrary.saveToLibraryAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n    }\n    return await MediaLibrary.saveToLibraryAsync(localUri);\n}\n// @needsAudit\n/**\n * Adds array of assets to the album.\n *\n * On Android, by default it copies assets from the current album to provided one, however it's also\n * possible to move them by passing `false` as `copyAssets` argument. In case they're copied you\n * should keep in mind that `getAssetsAsync` will return duplicated assets.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @param copy __Android only.__ Whether to copy assets to the new album instead of move them.\n * Defaults to `true`.\n * @return Returns promise which fulfils with `true` if the assets were successfully added to\n * the album.\n */\nexport async function addAssetsToAlbumAsync(assets, album, copy = true) {\n    if (!MediaLibrary.addAssetsToAlbumAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n    }\n    const assetIds = arrayize(assets).map(getId);\n    const albumId = getId(album);\n    checkAssetIds(assetIds);\n    if (!albumId || typeof albumId !== 'string') {\n        throw new Error('Invalid album ID. It must be a string!');\n    }\n    if (Platform.OS === 'ios') {\n        return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId);\n    }\n    return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId, !!copy);\n}\n// @needsAudit\n/**\n * Removes given assets from album.\n *\n * On Android, album will be automatically deleted if there are no more assets inside.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @return Returns promise which fulfils with `true` if the assets were successfully removed from\n * the album.\n */\nexport async function removeAssetsFromAlbumAsync(assets, album) {\n    if (!MediaLibrary.removeAssetsFromAlbumAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n    }\n    const assetIds = arrayize(assets).map(getId);\n    const albumId = getId(album);\n    checkAssetIds(assetIds);\n    return await MediaLibrary.removeAssetsFromAlbumAsync(assetIds, albumId);\n}\n// @needsAudit\n/**\n * Deletes assets from the library. On iOS it deletes assets from all albums they belong to, while\n * on Android it keeps all copies of them (album is strictly connected to the asset). Also, there is\n * additional dialog on iOS that requires user to confirm this action.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @return Returns promise which fulfils with `true` if the assets were successfully deleted.\n */\nexport async function deleteAssetsAsync(assets) {\n    if (!MediaLibrary.deleteAssetsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n    }\n    const assetIds = arrayize(assets).map(getId);\n    checkAssetIds(assetIds);\n    return await MediaLibrary.deleteAssetsAsync(assetIds);\n}\n// @needsAudit\n/**\n * Provides more information about an asset, including GPS location, local URI and EXIF metadata.\n * @param asset An [Asset](#asset) or its ID.\n * @param options\n * @return An [AssetInfo](#assetinfo) object, which is an `Asset` extended by an additional fields.\n */\nexport async function getAssetInfoAsync(asset, options = { shouldDownloadFromNetwork: true }) {\n    if (!MediaLibrary.getAssetInfoAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n    }\n    const assetId = getId(asset);\n    checkAssetIds([assetId]);\n    const assetInfo = await MediaLibrary.getAssetInfoAsync(assetId, options);\n    if (Array.isArray(assetInfo)) {\n        // Android returns an array with asset info, we need to pick the first item\n        return assetInfo[0];\n    }\n    return assetInfo;\n}\n// @needsAudit\n/**\n * Queries for user-created albums in media gallery.\n * @return A promise which fulfils with an array of [`Album`](#asset)s. Depending on Android version,\n * root directory of your storage may be listed as album titled `\"0\"` or unlisted at all.\n */\nexport async function getAlbumsAsync({ includeSmartAlbums = false } = {}) {\n    if (!MediaLibrary.getAlbumsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n    }\n    return await MediaLibrary.getAlbumsAsync({ includeSmartAlbums });\n}\n// @needsAudit\n/**\n * Queries for an album with a specific name.\n * @param title Name of the album to look for.\n * @return An object representing an [`Album`](#album), if album with given name exists, otherwise\n * returns `null`.\n */\nexport async function getAlbumAsync(title) {\n    if (!MediaLibrary.getAlbumAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n    }\n    if (typeof title !== 'string') {\n        throw new Error('Album title must be a string!');\n    }\n    return await MediaLibrary.getAlbumAsync(title);\n}\n// @needsAudit\n/**\n * Creates an album with given name and initial asset. The asset parameter is required on Android,\n * since it's not possible to create empty album on this platform. On Android, by default it copies\n * given asset from the current album to the new one, however it's also possible to move it by\n * passing `false` as `copyAsset` argument.\n * In case it's copied you should keep in mind that `getAssetsAsync` will return duplicated asset.\n * @param albumName Name of the album to create.\n * @param asset An [Asset](#asset) or its ID (required on Android).\n * @param copyAsset __Android Only.__ Whether to copy asset to the new album instead of move it.\n * Defaults to `true`.\n * @return Newly created [`Album`](#album).\n */\nexport async function createAlbumAsync(albumName, asset, copyAsset = true) {\n    if (!MediaLibrary.createAlbumAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n    }\n    const assetId = getId(asset);\n    if (Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0)) {\n        // it's not possible to create empty album on Android, so initial asset must be provided\n        throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n    }\n    if (!albumName || typeof albumName !== 'string') {\n        throw new Error('Invalid argument \"albumName\". It must be a string!');\n    }\n    if (assetId != null && typeof assetId !== 'string') {\n        throw new Error('Asset ID must be a string!');\n    }\n    if (Platform.OS === 'ios') {\n        return await MediaLibrary.createAlbumAsync(albumName, assetId);\n    }\n    return await MediaLibrary.createAlbumAsync(albumName, assetId, !!copyAsset);\n}\n// @needsAudit\n/**\n * Deletes given albums from the library. On Android by default it deletes assets belonging to given\n * albums from the library. On iOS it doesn't delete these assets, however it's possible to do by\n * passing `true` as `deleteAssets`.\n * @param albums An array of [`Album`](#asset)s or their IDs.\n * @param assetRemove __iOS Only.__ Whether to also delete assets belonging to given albums.\n * Defaults to `false`.\n * @return Returns a promise which fulfils with `true` if the albums were successfully deleted from\n * the library.\n */\nexport async function deleteAlbumsAsync(albums, assetRemove = false) {\n    if (!MediaLibrary.deleteAlbumsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n    }\n    const albumIds = arrayize(albums).map(getId);\n    checkAlbumIds(albumIds);\n    if (Platform.OS === 'android') {\n        return await MediaLibrary.deleteAlbumsAsync(albumIds);\n    }\n    return await MediaLibrary.deleteAlbumsAsync(albumIds, !!assetRemove);\n}\n// @needsAudit\n/**\n * Fetches a page of assets matching the provided criteria.\n * @param assetsOptions\n * @return A promise that fulfils with to [`PagedInfo`](#pagedinfo) object with array of [`Asset`](#asset)s.\n */\nexport async function getAssetsAsync(assetsOptions = {}) {\n    if (!MediaLibrary.getAssetsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n    }\n    const { first, after, album, sortBy, mediaType, createdAfter, createdBefore } = assetsOptions;\n    const options = {\n        first: first == null ? 20 : first,\n        after: getId(after),\n        album: getId(album),\n        sortBy: arrayize(sortBy),\n        mediaType: arrayize(mediaType || [MediaType.photo]),\n        createdAfter: dateToNumber(createdAfter),\n        createdBefore: dateToNumber(createdBefore),\n    };\n    if (first != null && typeof options.first !== 'number') {\n        throw new Error('Option \"first\" must be a number!');\n    }\n    if (after != null && typeof options.after !== 'string') {\n        throw new Error('Option \"after\" must be a string!');\n    }\n    if (album != null && typeof options.album !== 'string') {\n        throw new Error('Option \"album\" must be a string!');\n    }\n    if (after != null && Platform.OS === 'android' && isNaN(parseInt(getId(after), 10))) {\n        throw new Error('Option \"after\" must be a valid ID!');\n    }\n    if (first != null && first < 0) {\n        throw new Error('Option \"first\" must be a positive integer!');\n    }\n    options.sortBy.forEach(checkSortBy);\n    options.mediaType.forEach(checkMediaType);\n    options.sortBy = options.sortBy.map(sortByOptionToString);\n    return await MediaLibrary.getAssetsAsync(options);\n}\n// @needsAudit\n/**\n * Subscribes for updates in user's media library.\n * @param listener A callback that is fired when any assets have been inserted or deleted from the\n * library. On Android it's invoked with an empty object. On iOS, it's invoked with [`MediaLibraryAssetsChangeEvent`](#medialibraryassetschangeevent)\n * object.\n *\n * Additionally, only on iOS, the listener is also invoked when the user changes access to individual assets in the media library\n * using `presentPermissionsPickerAsync()`.\n * @return An [`Subscription`](#subscription) object that you can call `remove()` on when you would\n * like to unsubscribe the listener.\n */\nexport function addListener(listener) {\n    return MediaLibrary.addListener(MediaLibrary.CHANGE_LISTENER_NAME, listener);\n}\n// @docsMissing\nexport function removeSubscription(subscription) {\n    subscription.remove();\n}\n// @needsAudit\n/**\n * Removes all listeners.\n */\nexport function removeAllListeners() {\n    MediaLibrary.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);\n}\n// @needsAudit\n/**\n * Fetches a list of moments, which is a group of assets taken around the same place\n * and time.\n * @return An array of [albums](#album) whose type is `moment`.\n * @platform ios\n */\nexport async function getMomentsAsync() {\n    if (!MediaLibrary.getMomentsAsync) {\n        throw new UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n    }\n    return await MediaLibrary.getMomentsAsync();\n}\n// @needsAudit\n/**\n * Moves album content to the special media directories on **Android R** or **above** if needed.\n * Those new locations are in line with the Android `scoped storage` - so your application won't\n * lose write permission to those directories in the future.\n *\n * This method does nothing if:\n * - app is running on **iOS**, **web** or **Android below R**\n * - app has **write permission** to the album folder\n *\n * The migration is possible when the album contains only compatible files types.\n * For instance, movies and pictures are compatible with each other, but music and pictures are not.\n * If automatic migration isn't possible, the function rejects.\n * In that case, you can use methods from the `expo-file-system` to migrate all your files manually.\n *\n * # Why do you need to migrate files?\n * __Android R__ introduced a lot of changes in the storage system. Now applications can't save\n * anything to the root directory. The only available locations are from the `MediaStore` API.\n * Unfortunately, the media library stored albums in folders for which, because of those changes,\n * the application doesn't have permissions anymore. However, it doesn't mean you need to migrate\n * all your albums. If your application doesn't add assets to albums, you don't have to migrate.\n * Everything will work as it used to. You can read more about scoped storage in [the Android documentation](https://developer.android.com/about/versions/11/privacy/storage).\n *\n * @param album An [Album](#album) or its ID.\n * @return A promise which fulfils to `void`.\n */\nexport async function migrateAlbumIfNeededAsync(album) {\n    if (!MediaLibrary.migrateAlbumIfNeededAsync) {\n        return;\n    }\n    return await MediaLibrary.migrateAlbumIfNeededAsync(getId(album));\n}\n// @needsAudit\n/**\n * Checks if the album should be migrated to a different location. In other words, it checks if the\n * application has the write permission to the album folder. If not, it returns `true`, otherwise `false`.\n * > Note: For **Android below R**, **web** or **iOS**, this function always returns `false`.\n * @param album An [Album](#album) or its ID.\n * @return Returns a promise which fulfils with `true` if the album should be migrated.\n */\nexport async function albumNeedsMigrationAsync(album) {\n    if (!MediaLibrary.albumNeedsMigrationAsync) {\n        return false;\n    }\n    return await MediaLibrary.albumNeedsMigrationAsync(getId(album));\n}\n//# sourceMappingURL=MediaLibrary.js.map","import { PermissionStatus } from 'expo-modules-core';\nconst noPermissionResponse = {\n    status: PermissionStatus.UNDETERMINED,\n    canAskAgain: true,\n    granted: false,\n    expires: 'never',\n};\nexport default {\n    get CHANGE_LISTENER_NAME() {\n        return 'mediaLibraryDidChange';\n    },\n    get MediaType() {\n        return {\n            audio: 'audio',\n            photo: 'photo',\n            video: 'video',\n            unknown: 'unknown',\n        };\n    },\n    get SortBy() {\n        return {\n            default: 'default',\n            mediaType: 'mediaType',\n            width: 'width',\n            height: 'height',\n            creationTime: 'creationTime',\n            modificationTime: 'modificationTime',\n            duration: 'duration',\n        };\n    },\n    async getPermissionsAsync(_writeOnly) {\n        return noPermissionResponse;\n    },\n    async requestPermissionsAsync(_writeOnly) {\n        return noPermissionResponse;\n    },\n};\n//# sourceMappingURL=ExpoMediaLibrary.web.js.map"],"x_facebook_sources":[[{"names":["<global>","numberIcon","buildGPX","pts.map$argument_0","buildGeoJSON","downloadText","ensureDomToImage","Promise$argument_0","script.onload","script.onerror","QuestFullMap","useEffect$argument_0","<anonymous>","ensureLeafletCSS","ensureLeaflet","useMemo$argument_0","steps.filter$argument_0","points.forEach$argument_0","Array.from.sort$argument_0","shareAsPNG","shareAsGPX","shareAsGeoJSON","exportPNG","exportGPX","exportGeoJSON","points.map$argument_0","FitBounds","map.whenReady$argument_0","requestAnimationFrame$argument_0","TouchableOpacity.props.onPress","Modal.props.onRequestClose","groupedPoints.map$argument_0"],"mappings":"AAA;ACgC;CDY;AEE;aCE,0ED;CFQ;AIE;2BDK;kBCI;6CDK,mBC;CJS;AKE;CLU;AME;8DCK;4BCI,eD;6BEC;aFG;SDE;CNU;eUE;cCe;SCC;yCCE;iBDQ;sCEE;2EPO;4CCI,eD;6CEC;6BFG;yBOE;iBFK;SD6B;KDC;QKG,mBC,qDD,CL;kCKK;uBEG;SFc;YGG,yDH;KLE;uBSG;KTiB;uBUE;KVqB;2BWE;KXqB;sBYE;KZa;sBaE;kGbC;0BcC;2GdC;6CeW,uCf;gCgBG;kBfG;0BgBG;sCCc,0BD;ahBC;SeC;KhBG;iCmByB,gCnB;gCoBY,iCpB;6BmBK,iCnB;qCmBO;6BnBG;qCmBO;6BnBG;qCmBO;6BnBG;qCmBO,iCnB;8Ce0B,mBf;2CqBM;yBrBoB;CVa"}],[{"names":["<global>"],"mappings":"AAA"}],[{"names":["<global>","normalizeEndingSlash","getInfoAsync","readAsStringAsync","getContentUriAsync","writeAsStringAsync","deleteAsync","deleteLegacyDocumentDirectoryAndroid","moveAsync","copyAsync","makeDirectoryAsync","readDirectoryAsync","getFreeDiskStorageAsync","getTotalDiskCapacityAsync","downloadAsync","uploadAsync","createDownloadResumable","createUploadTask","FileSystemCancellableNetworkTask","FileSystemCancellableNetworkTask#cancelAsync","FileSystemCancellableNetworkTask#isTaskCancelled","FileSystemCancellableNetworkTask#get__uuid","FileSystemCancellableNetworkTask#addSubscription","ExponentFileSystem.addListener$argument_1","FileSystemCancellableNetworkTask#removeSubscription","UploadTask","UploadTask#constructor","UploadTask#getEventName","UploadTask#getCallback","UploadTask#uploadAsync","DownloadResumable","DownloadResumable#constructor","DownloadResumable#get__fileUri","DownloadResumable#getEventName","DownloadResumable#getCallback","DownloadResumable#downloadAsync","DownloadResumable#pauseAsync","DownloadResumable#resumeAsync","DownloadResumable#savable","getUriForDirectoryInRoot","requestDirectoryPermissionsAsync","createFileAsync"],"mappings":"AAA;ACiC;CDK;OE4B;CFK;OGQ;CHQ;OImB;CJS;OKS;CLS;OMO;CNK;OOE;CPM;OQM;CRK;OSO;CTK;OUO;CVQ;OWO;CXK;OYM;CZK;OaM;CbK;OcuB;Cda;Oe8B;Cfe;OgBkB;ChBQ;OiBE;CjBO;OkBE;ECQ;GDQ;EEE;GFO;EGE;GHE;EIM;MCO;ODO;GJE;EME;GNM;ClBC;OyBE;ECG;GDiB;EEE;GFE;EGC;GHE;EIG;GJmB;CzBC;O8BE;ECC;GDQ;EEE;GFE;EGE;GHE;EIE;GJE;EKM;GLiB;EMO;GNqB;EOM;GPiB;EQM;GRO;C9BC;SuCgG;GvCE;SwCS;GxCW;SWO;GXQ;SUQ;GVQ;SyCS;GzCS"}],[{"names":["<global>"],"mappings":"AAA"}],[{"names":["<global>","FileSystemShim"],"mappings":"AAA;eCI;CDO"}],[{"names":["<global>"],"mappings":"AAA"}],[{"names":["<global>","isAvailableAsync","shareAsync"],"mappings":"AAA;OCO;CDQ;OEO;CFK"}],[{"names":["<global>","default.isAvailableAsync","default.shareAsync"],"mappings":"AAA;ICE;KDK;IEC;KFQ"}],[{"names":["<global>","arrayize","getId","checkAssetIds","assetIds.some$argument_0","checkAlbumIds","albumIds.some$argument_0","checkMediaType","checkSortBy","checkSortByKey","sortByOptionToString","dateToNumber","isAvailableAsync","requestPermissionsAsync","getPermissionsAsync","createPermissionHook$argument_0.getMethod","createPermissionHook$argument_0.requestMethod","presentPermissionsPickerAsync","createAssetAsync","saveToLibraryAsync","addAssetsToAlbumAsync","removeAssetsFromAlbumAsync","deleteAssetsAsync","getAssetInfoAsync","getAlbumsAsync","getAlbumAsync","createAlbumAsync","deleteAlbumsAsync","getAssetsAsync","addListener","removeSubscription","removeAllListeners","getMomentsAsync","migrateAlbumIfNeededAsync","albumNeedsMigrationAsync"],"mappings":"AAA;ACU;CDK;AEC;CFK;AGC;sBCC,qCD;CHG;AKC;sBCC,qCD;CLG;AOC;CPI;AQC;CRU;ASC;CTI;AUC;CVK;AWC;CXE;OYiB;CZE;OaS;CbQ;OcS;CdQ;eea,kFf;mBgBC,sFhB;OiBiB;CjBY;OkBe;ClBa;OmBU;CnBK;OoBe;CpBc;OqBW;CrBQ;OsBS;CtBO;OuBQ;CvBY;OwBO;CxBK;OyBQ;CzBQ;O0Bc;C1BmB;O2BY;C3BU;O4BO;C5BiC;O6Ba;C7BE;O8BE;C9BE;O+BK;C/BE;OgCQ;ChCK;OiC2B;CjCK;OkCS;ClCK"}],[{"names":["<global>","default.get__CHANGE_LISTENER_NAME","default.get__MediaType","default.get__SortBy","default.getPermissionsAsync","default.requestPermissionsAsync"],"mappings":"AAA;ICQ;KDE;IEC;KFO;IGC;KHU;IIC;KJE;IKC;KLE"}]],"x_google_ignoreList":[1,2,3,4,5,6,7,8,9],"names":["steps","height","title","mods","setMods","useState","exportMenuVisible","setExportMenuVisible","mapDivRef","useRef","insets","useSafeAreaInsets","width","screenWidth","Dimensions","get","useEffect","ensureLeafletCSS","href","document","querySelector","link","createElement","rel","head","appendChild","ensureLeaflet","async","w","window","L","_loader","Promise","resolve","reject","script","src","onload","onerror","err","body","RL","_r","d","paths","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","MapContainer","TileLayer","Marker","Polyline","Popup","FeatureGroup","useMap","error","console","points","useMemo","filter","s","Number","isFinite","lat","lng","groupedPoints","map","Map","forEach","p","i","key","toFixed","has","gp","indexes","push","titles","set","Array","from","values","sort","a","b","Math","min","shareAsPNG","exportPNG","shareAsGPX","exportGPX","shareAsGeoJSON","exportGeoJSON","domtoimage","ensureDomToImage","node","current","dataUrl","toPng","quality","download","replace","click","print","downloadText","buildGPX","buildGeoJSON","length","_jsxRuntime","jsx","_View","default","style","styles","wrap","children","_Text","loadingText","bounds","latLngBounds","pad","FitBounds","whenReady","container","getContainer","clientWidth","clientHeight","getBounds","contains","fitBounds","animate","requestAnimationFrame","invalidateSize","jsxs","toolbar","paddingTop","top","toolbarTitle","numberOfLines","webButtons","_Pressable","btn","onPress","btnTxt","_Modal","visible","transparent","animationType","onRequestClose","_TouchableOpacity","modalOverlay","activeOpacity","modalContent","bottom","modalTitle","modalOption","modalOptionText","cancelOption","cancelOptionText","ref","mapBox","scrollWheelZoom","zoomControl","dragging","touchZoom","doubleClickZoom","attribution","url","positions","pathOptions","color","weight","idx","position","icon","numberIcon","join","includes","minWidth","popupTitle","popupCoords","marginTop","_react","_interopRequireWildcard","_interopRequireDefault","_StyleSheet","_Dimensions","_reactNativeSafeAreaContext","e","t","WeakMap","r","n","__esModule","o","f","__proto__","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","active","html","String","divIcon","className","iconSize","iconAnchor","pts","JSON","stringify","type","features","geometry","coordinates","properties","order","name","filename","text","blob","Blob","URL","createObjectURL","remove","revokeObjectURL","Error","StyleSheet","create","borderRadius","overflow","borderWidth","borderColor","backgroundColor","paddingHorizontal","paddingVertical","borderBottomWidth","borderBottomColor","flexDirection","alignItems","justifyContent","minHeight","fontWeight","fontSize","flex","marginRight","gap","mobileMenuButton","padding","mobileMenuText","textAlign","borderTopLeftRadius","borderTopRightRadius","paddingBottom","marginBottom","touchHints","borderTopWidth","borderTopColor","hintText","_FileSystem","keys","enumerable","_FileSystem2","uri","fileUri","options","callback","resumeData","DownloadResumable","UploadTask","ExponentFileSystem","downloadAsync","UnavailabilityError","sessionType","FileSystemSessionType","BACKGROUND","getFreeDiskStorageAsync","getInfoAsync","getTotalDiskCapacityAsync","makeDirectoryAsync","readDirectoryAsync","uploadAsync","uploadType","FileSystemUploadType","BINARY_CONTENT","httpMethod","toUpperCase","_expoModulesCore","_ExponentFileSystem","normalizeEndingSlash","warn","documentDirectory","cacheDirectory","bundleDirectory","readAsStringAsync","writeAsStringAsync","contents","deleteAsync","moveAsync","copyAsync","FileSystemCancellableNetworkTask","_uuid","uuid","v4","taskWasCanceled","cancelAsync","networkTaskCancelAsync","this","removeSubscription","isTaskCancelled","addSubscription","subscription","addListener","getEventName","event","getCallback","data","constructor","super","uploadTaskStartAsync","result","_fileUri","downloadResumableStartAsync","pauseAsync","downloadResumablePauseAsync","pauseResult","savable","resumeAsync","baseReadAsStringAsync","baseWriteAsStringAsync","baseDeleteAsync","baseMoveAsync","baseCopyAsync","StorageAccessFramework","undefined","_StorageAccessFramework","getUriForDirectoryInRoot","folderName","requestDirectoryPermissionsAsync","initialFileUrl","dirUri","readSAFDirectoryAsync","parentUri","dirName","makeSAFDirectoryAsync","createFileAsync","fileName","mimeType","createSAFFileAsync","_ExponentFileSystemShim","ExponentFileSystemShim","FileSystemShim","NativeModule","EncodingType","Sharing","isAvailableAsync","shareAsync","_ExpoSharing","navigator","share","assets","album","copy","MediaLibrary","addAssetsToAlbumAsync","assetIds","arrayize","getId","albumId","checkAssetIds","listener","CHANGE_LISTENER_NAME","albumNeedsMigrationAsync","albumName","asset","copyAsset","createAlbumAsync","assetId","localUri","createAssetAsync","isArray","albums","assetRemove","deleteAlbumsAsync","albumIds","checkAlbumIds","deleteAssetsAsync","getAlbumAsync","includeSmartAlbums","getAlbumsAsync","shouldDownloadFromNetwork","getAssetInfoAsync","assetInfo","assetsOptions","getAssetsAsync","first","after","sortBy","mediaType","createdAfter","createdBefore","MediaType","photo","dateToNumber","checkSortBy","checkMediaType","sortByOptionToString","getMomentsAsync","migrateAlbumIfNeededAsync","mediaTypes","presentPermissionsPickerAsync","removeAllListeners","removeAssetsFromAlbumAsync","saveToLibraryAsync","_ExpoMediaLibrary","loggedExpoGoWarning","item","id","some","indexOf","checkSortByKey","SortBy","value","Date","getTime","expo","globalThis","modules","ExpoGo","requestPermissionsAsync","writeOnly","granularPermissions","getPermissionsAsync","usePermissions","createPermissionHook","getMethod","requestMethod","noPermissionResponse","status","PermissionStatus","UNDETERMINED","canAskAgain","granted","expires","audio","video","unknown","creationTime","modificationTime","duration","_writeOnly"],"mappings":"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","debugId":"e23973f1-2145-495e-b616-81f4d8829340"}