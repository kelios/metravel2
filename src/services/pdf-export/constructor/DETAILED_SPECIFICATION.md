# Детальное техническое задание: Визуальный конструктор PDF

## Версия: 2.0 (Доработанная)
## Дата: 2024
## Статус: В разработке

---

## 1. EXECUTIVE SUMMARY

### 1.1. Текущее состояние

**Реализовано (MVP)**:
- ✅ Базовая архитектура конструктора
- ✅ Система блоков и страниц
- ✅ 5 встроенных тем
- ✅ Импорт статьи в конструктор
- ✅ Рендеринг страниц в изображения (Canvas → PNG/WebP)
- ✅ Сборка PDF из изображений
- ✅ Базовый UI (палитра блоков, панель стилей, навигатор)

**Не реализовано (критично)**:
- ❌ Drag & Drop для перестановки блоков
- ❌ Inline редактирование текста
- ❌ Визуальное изменение размеров блоков
- ❌ Параметры страницы в UI

### 1.2. Цель доработки

Довести конструктор до полнофункционального состояния, соответствующего требованиям пользователя:
- Визуальное редактирование с drag & drop
- Прямое редактирование контента
- Гибкая настройка макета
- Профессиональный результат экспорта

---

## 2. ДЕТАЛЬНЫЕ ТРЕБОВАНИЯ

### 2.1. Drag & Drop система

#### FR-001: Перетаскивание блоков на странице

**Описание**:
Пользователь должен иметь возможность перетаскивать блоки по странице для изменения их позиции.

**Детальные требования**:

1. **Инициализация перетаскивания**:
   - При наведении на блок курсор меняется на "move" (grab cursor)
   - При нажатии и удержании (mousedown/touchstart) блок входит в режим перетаскивания
   - Визуальная обратная связь: блок становится полупрозрачным (opacity: 0.7)
   - Появляется призрачная копия блока, следующая за курсором

2. **Во время перетаскивания**:
   - Блок следует за курсором/пальцем
   - Показывается индикатор позиции вставки (линия или подсветка области)
   - При наведении на другой блок показывается, куда будет вставлен
   - Поддержка перетаскивания между страницами (показывать индикатор целевой страницы)

3. **Завершение перетаскивания**:
   - При отпускании (mouseup/touchend) блок размещается на новой позиции
   - Координаты обновляются в модели данных
   - Блок возвращается к нормальной прозрачности
   - Призрачная копия исчезает

**Техническая реализация**:

```typescript
// Компонент DraggableBlock
interface DraggableBlockProps {
  block: PdfBlock;
  page: PdfPage;
  onDragStart: (blockId: string) => void;
  onDragEnd: (blockId: string, newPosition: BlockPosition) => void;
  onDrag: (blockId: string, x: number, y: number) => void;
}

// Использование @dnd-kit или собственной реализации
import { useDraggable } from '@dnd-kit/core';

function DraggableBlock({ block, onDragEnd }: DraggableBlockProps) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: block.id,
  });

  const style = {
    transform: transform ? `translate3d(${transform.x}px, ${transform.y}px, 0)` : undefined,
    opacity: isDragging ? 0.7 : 1,
  };

  return (
    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>
      {/* Содержимое блока */}
    </div>
  );
}
```

**Критерии приемки**:
- ✅ Блок можно перетащить в любую точку страницы
- ✅ Координаты обновляются в реальном времени
- ✅ Работает на всех типах блоков
- ✅ Поддержка touch-устройств
- ✅ Плавная анимация (60 FPS)

#### FR-002: Перетаскивание между страницами

**Описание**:
Пользователь должен иметь возможность перетаскивать блоки между страницами.

**Детали**:
- При перетаскивании блока к краю страницы показывать индикатор следующей/предыдущей страницы
- Автоматическое переключение страницы при достижении края
- Блок удаляется с исходной страницы и добавляется на целевую

### 2.2. Inline редактирование

#### FR-003: Прямое редактирование текста

**Описание**:
Пользователь должен иметь возможность редактировать текст напрямую на холсте, без открытия панели стилей.

**Детальные требования**:

1. **Активация редактирования**:
   - Двойной клик по текстовому блоку активирует режим редактирования
   - Текст становится редактируемым (contentEditable или input)
   - Появляется курсор в месте клика
   - Блок визуально выделяется (рамка, фон)

2. **Во время редактирования**:
   - Текст можно редактировать как обычный текст
   - Поддержка выделения текста
   - Горячие клавиши:
     - Ctrl+B / Cmd+B - жирный
     - Ctrl+I / Cmd+I - курсив
     - Ctrl+U / Cmd+U - подчеркивание
   - Автоматическое изменение размера блока при изменении текста

3. **Завершение редактирования**:
   - При потере фокуса (клик вне блока, Tab, Enter) изменения сохраняются
   - Текст обновляется в модели данных
   - Блок возвращается к нормальному виду

**Техническая реализация**:

```typescript
// Компонент EditableTextBlock
interface EditableTextBlockProps {
  block: PdfBlock;
  isEditing: boolean;
  onStartEdit: () => void;
  onEndEdit: (text: string) => void;
}

function EditableTextBlock({ block, isEditing, onStartEdit, onEndEdit }: EditableTextBlockProps) {
  const [text, setText] = useState(typeof block.content === 'string' ? block.content : '');

  if (isEditing) {
    return (
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        onBlur={() => onEndEdit(text)}
        onKeyDown={(e) => {
          if (e.key === 'Escape') {
            onEndEdit(text);
          }
        }}
        style={{
          width: '100%',
          height: '100%',
          border: '2px solid #ff9f5a',
          padding: 4,
        }}
        autoFocus
      />
    );
  }

  return (
    <div onDoubleClick={onStartEdit}>
      {text}
    </div>
  );
}
```

**Критерии приемки**:
- ✅ Двойной клик активирует редактирование
- ✅ Изменения сохраняются при потере фокуса
- ✅ Работает для всех текстовых блоков
- ✅ Горячие клавиши работают

### 2.3. Изменение размеров блоков

#### FR-004: Визуальные маркеры изменения размера

**Описание**:
Пользователь должен иметь возможность изменять размеры блоков визуально через маркеры.

**Детальные требования**:

1. **Маркеры**:
   - 8 маркеров: 4 угла + 4 стороны
   - Появляются при выделении блока
   - Визуально видны (квадратики или кружки)
   - При наведении курсор меняется (resize cursor)

2. **Изменение размера**:
   - Перетаскивание маркера изменяет размер блока
   - При зажатом Shift сохраняются пропорции
   - Минимальные размеры: 20x20px
   - Максимальные размеры: размер страницы

3. **Обратная связь**:
   - Показывать текущие размеры во время изменения
   - Визуальная подсветка маркера при наведении
   - Плавная анимация изменения размера

**Техническая реализация**:

```typescript
// Компонент ResizeHandles
interface ResizeHandlesProps {
  block: PdfBlock;
  onResize: (newWidth: number, newHeight: number) => void;
  onResizeStart: () => void;
  onResizeEnd: () => void;
}

function ResizeHandles({ block, onResize, onResizeStart, onResizeEnd }: ResizeHandlesProps) {
  const [isResizing, setIsResizing] = useState(false);
  const [startPos, setStartPos] = useState({ x: 0, y: 0 });
  const [startSize, setStartSize] = useState({ width: 0, height: 0 });

  const handleMouseDown = (e: React.MouseEvent, handle: string) => {
    e.stopPropagation();
    setIsResizing(true);
    setStartPos({ x: e.clientX, y: e.clientY });
    setStartSize({ width: block.position.width, height: block.position.height });
    onResizeStart();
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (!isResizing) return;
    
    const deltaX = e.clientX - startPos.x;
    const deltaY = e.clientY - startPos.y;
    
    // Вычисляем новый размер в зависимости от маркера
    const newWidth = startSize.width + deltaX;
    const newHeight = startSize.height + deltaY;
    
    onResize(newWidth, newHeight);
  };

  // 8 маркеров в углах и на сторонах
  const handles = [
    { position: 'top-left', cursor: 'nw-resize' },
    { position: 'top', cursor: 'n-resize' },
    { position: 'top-right', cursor: 'ne-resize' },
    { position: 'right', cursor: 'e-resize' },
    { position: 'bottom-right', cursor: 'se-resize' },
    { position: 'bottom', cursor: 's-resize' },
    { position: 'bottom-left', cursor: 'sw-resize' },
    { position: 'left', cursor: 'w-resize' },
  ];

  return (
    <>
      {handles.map((handle) => (
        <div
          key={handle.position}
          style={{
            position: 'absolute',
            [handle.position.includes('top') ? 'top' : 'bottom']: -4,
            [handle.position.includes('left') ? 'left' : 'right']: -4,
            width: 8,
            height: 8,
            backgroundColor: '#ff9f5a',
            border: '1px solid #fff',
            cursor: handle.cursor,
            zIndex: 1000,
          }}
          onMouseDown={(e) => handleMouseDown(e, handle.position)}
        />
      ))}
    </>
  );
}
```

**Критерии приемки**:
- ✅ Маркеры появляются при выделении
- ✅ Размер изменяется при перетаскивании
- ✅ Пропорции сохраняются с Shift
- ✅ Минимальные/максимальные размеры соблюдаются

### 2.4. Параметры страницы в UI

#### FR-005: Настройка формата и ориентации

**Описание**:
Пользователь должен иметь возможность изменять формат и ориентацию страницы через интерфейс.

**Детальные требования**:

1. **UI элементы**:
   - Выпадающий список форматов (A4, A5, A6, Letter)
   - Переключатель ориентации (Portrait ↔ Landscape)
   - Кнопка "Применить"
   - Предпросмотр изменений

2. **Применение изменений**:
   - При изменении формата все страницы обновляются
   - Блоки масштабируются пропорционально (опционально)
   - Предупреждение при изменении (может повлиять на макет)

3. **Визуальная обратная связь**:
   - Холст обновляется сразу после применения
   - Показывается новый размер страницы

**Техническая реализация**:

```typescript
// Компонент PageSettingsPanel
function PageSettingsPanel({ 
  document, 
  onUpdate 
}: { 
  document: PdfDocument; 
  onUpdate: (format: PageFormat, orientation: PageOrientation) => void;
}) {
  const [format, setFormat] = useState(document.format);
  const [orientation, setOrientation] = useState(document.orientation);

  const handleApply = () => {
    if (confirm('Изменение формата может повлиять на расположение блоков. Продолжить?')) {
      onUpdate(format, orientation);
    }
  };

  return (
    <div style={{ padding: 16 }}>
      <label>
        Формат:
        <select value={format} onChange={(e) => setFormat(e.target.value as PageFormat)}>
          <option value="A4">A4 (210×297 мм)</option>
          <option value="A5">A5 (148×210 мм)</option>
          <option value="A6">A6 (105×148 мм)</option>
          <option value="Letter">Letter (216×279 мм)</option>
        </select>
      </label>
      
      <label>
        Ориентация:
        <button onClick={() => setOrientation(orientation === 'portrait' ? 'landscape' : 'portrait')}>
          {orientation === 'portrait' ? 'Книжная' : 'Альбомная'}
        </button>
      </label>
      
      <button onClick={handleApply}>Применить</button>
    </div>
  );
}
```

**Критерии приемки**:
- ✅ Формат можно изменить в любой момент
- ✅ Ориентация меняется мгновенно
- ✅ Блоки адаптируются к новому формату
- ✅ Предупреждение показывается при необходимости

### 2.5. История изменений

#### FR-006: Undo/Redo система

**Описание**:
Пользователь должен иметь возможность отменять и повторять действия.

**Детальные требования**:

1. **Сохранение истории**:
   - Каждое действие сохраняется в историю
   - Ограничение: 50 последних действий
   - Состояние документа сериализуется

2. **Управление**:
   - Горячие клавиши: Ctrl+Z (undo), Ctrl+Shift+Z (redo)
   - Кнопки в тулбаре
   - Показывать количество доступных действий

3. **Действия для отслеживания**:
   - Добавление/удаление блока
   - Изменение позиции блока
   - Изменение стилей блока
   - Изменение контента блока
   - Добавление/удаление страницы
   - Изменение темы

**Техническая реализация**:

```typescript
// Сервис HistoryManager
export class HistoryManager {
  private history: PdfDocument[] = [];
  private currentIndex: number = -1;
  private maxHistorySize: number = 50;

  push(document: PdfDocument): void {
    // Удаляем все действия после текущего индекса (если был undo)
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    // Добавляем новое состояние
    this.history.push(JSON.parse(JSON.stringify(document)));
    
    // Ограничиваем размер истории
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
  }

  undo(): PdfDocument | null {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return JSON.parse(JSON.stringify(this.history[this.currentIndex]));
    }
    return null;
  }

  redo(): PdfDocument | null {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      return JSON.parse(JSON.stringify(this.history[this.currentIndex]));
    }
    return null;
  }

  canUndo(): boolean {
    return this.currentIndex > 0;
  }

  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
}
```

**Критерии приемки**:
- ✅ Можно отменить любое действие
- ✅ Можно повторить отмененное действие
- ✅ История ограничена 50 действиями
- ✅ Горячие клавиши работают

### 2.6. Копирование/вставка

#### FR-007: Копирование блоков

**Описание**:
Пользователь должен иметь возможность копировать и вставлять блоки.

**Детали**:
- Горячие клавиши: Ctrl+C (копировать), Ctrl+V (вставить)
- Кнопки в контекстном меню
- Копирование между страницами
- Копирование стилей отдельно (опционально)

### 2.7. Доработка рендерера

#### FR-008: Полная поддержка всех типов блоков

**Описание**:
Все типы блоков должны корректно рендериться в изображения.

**Проверка и доработка**:
- ✅ Заголовки - работает
- ✅ Параграфы - работает
- ⚠️ Галереи - требуется проверка
- ⚠️ Таблицы - требуется проверка
- ⚠️ Чек-листы - требуется проверка
- ⚠️ Оглавление - требуется проверка
- ⚠️ Обложка - требуется проверка

---

## 3. UX СЦЕНАРИИ

### 3.1. Сценарий 1: Создание документа с нуля

1. Пользователь открывает конструктор
2. Видит пустую страницу
3. Нажимает "+ Блок" → выбирает "Обложка"
4. Двойным кликом редактирует текст обложки
5. Перетаскивает блок обложки для изменения позиции
6. Добавляет блок "Заголовок H1"
7. Добавляет блок "Абзац" с текстом
8. Добавляет блок "Фото"
9. Нажимает "Экспорт PDF"
10. Получает готовый PDF

### 3.2. Сценарий 2: Импорт и редактирование статьи

1. Пользователь открывает статью
2. Нажимает "Экспорт PDF" → "Открыть конструктор"
3. Видит автоматически созданные страницы с блоками
4. Перетаскивает блоки для изменения порядка
5. Редактирует текст inline (двойной клик)
6. Изменяет размеры блоков через маркеры
7. Меняет тему документа
8. Экспортирует PDF

### 3.3. Сценарий 3: Точная настройка макета

1. Пользователь выбирает страницу
2. Выделяет блок
3. Изменяет размер через маркеры
4. Перетаскивает в нужную позицию
5. Редактирует стили через панель
6. Копирует блок (Ctrl+C)
7. Вставляет на другую страницу (Ctrl+V)
8. Отменяет действие (Ctrl+Z) если не понравилось

---

## 4. ТЕХНИЧЕСКАЯ АРХИТЕКТУРА

### 4.1. Компоненты для реализации

#### Новые компоненты:

1. **DraggableBlock.tsx**
   - Обертка для блока с поддержкой drag & drop
   - Использует @dnd-kit или собственную реализацию

2. **EditableTextBlock.tsx**
   - Компонент для inline редактирования текста
   - contentEditable или textarea

3. **ResizeHandles.tsx**
   - Маркеры изменения размера
   - 8 маркеров, обработка событий мыши

4. **PageSettingsPanel.tsx**
   - Панель настройки параметров страницы
   - Выбор формата и ориентации

5. **HistoryManager.ts**
   - Сервис для управления историей изменений
   - Command pattern

### 4.2. Обновление существующих компонентов

1. **PageCanvas.tsx**
   - Добавить поддержку drag & drop
   - Добавить inline редактирование
   - Добавить маркеры изменения размера

2. **PdfConstructor.tsx**
   - Интеграция HistoryManager
   - Обработка горячих клавиш
   - UI для параметров страницы

3. **PageImageRenderer.ts**
   - Доработка рендеринга всех типов блоков
   - Оптимизация производительности

---

## 5. ПРИОРИТИЗАЦИЯ И ПЛАН

### Фаза 1: Критичные функции (6-9 дней)
1. Drag & Drop (2-3 дня)
2. Inline редактирование (1-2 дня)
3. Изменение размеров (1-2 дня)
4. Доработка рендерера (2-3 дня)

### Фаза 2: Улучшения UX (4-5 дней)
1. Параметры страницы (1 день)
2. История изменений (2 дня)
3. Копирование/вставка (1 день)
4. Улучшение панели стилей (1 день)

### Фаза 3: Дополнительно (4-5 дней)
1. Шаблоны (1-2 дня)
2. Сохранение макетов (1 день)
3. Выравнивание (1-2 дня)
4. Предпросмотр 1:1 (1 день)

---

## 6. КРИТЕРИИ УСПЕХА

### Функциональные
- ✅ Все блоки можно перетаскивать
- ✅ Текст можно редактировать inline
- ✅ Размеры можно изменять визуально
- ✅ Все блоки корректно рендерятся

### Производительность
- ✅ 60 FPS при перетаскивании
- ✅ Нет лагов при редактировании
- ✅ Быстрый экспорт (< 10 сек для 10 страниц)

### UX
- ✅ Интуитивный интерфейс
- ✅ Визуальная обратная связь
- ✅ Работает на всех устройствах

---

## 7. ЗАКЛЮЧЕНИЕ

Текущая реализация - отличная база. Основные пробелы:
1. **Drag & Drop** - критично для удобства
2. **Inline редактирование** - критично для скорости работы
3. **Изменение размеров** - важно для точной настройки

Рекомендуется начать с Фазы 1, затем протестировать на пользователях и итеративно добавлять функции.

