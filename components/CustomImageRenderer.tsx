import React, { useEffect, useMemo, useState } from "react";
import {
  View,
  Platform,
  useWindowDimensions,
  ActivityIndicator,
  Text,
  StyleSheet,
  Image as RNImage,
} from "react-native";
import { CustomRendererProps } from "react-native-render-html";
import { Image as ExpoImage } from "expo-image";

interface CustomImageRendererProps extends CustomRendererProps {
  contentWidth: number;
}

const MAX_WIDTH = 800;
const H_PADDING = 16;
const BORDER_PADDING = 8;

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const pickSrc = (tnode: any) => {
  const a = tnode?.attributes || {};
  const raw = a.src || a["data-src"] || "";
  if (!raw && a.srcset) {
    const first = String(a.srcset).split(",")[0]?.trim().split(/\s+/)[0];
    return first || "";
  }
  return raw;
};

const isPrivateHost = (host: string) => {
  return (
    host === "localhost" ||
    host.endsWith(".local") ||
    /^127\.0\.0\.1$/.test(host) ||
    /^10\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(host) ||
    /^192\.168\.\d{1,3}\.\d{1,3}$/.test(host) ||
    /^172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3}$/.test(host)
  );
};

const normalizeUrl = (url: string) => {
  let u = (url || "").trim();
  if (!u) return u;

  // protocol-relative -> inherit page protocol (–ø—Ä–µ–¥–ø–æ—á—Ç—ë–º https, –Ω–æ –Ω–µ –ª–æ–º–∞–µ–º dev)
  if (u.startsWith("//")) {
    const pageProto = typeof window !== "undefined" ? window.location.protocol : "https:";
    u = `${pageProto}${u}`;
  }

  // –ï—Å–ª–∏ —ç—Ç–æ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π URL ‚Äî —Ä–µ—à–∞–µ–º, –∞–ø–≥—Ä–µ–π–¥–∏—Ç—å –ª–∏ –¥–æ https
  try {
    const parsed = new URL(u, typeof window !== "undefined" ? window.location.href : "http://localhost");
    const host = parsed.hostname;

    // –î–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö/–ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å (–∏–Ω–∞—á–µ ERR_CONNECTION_REFUSED)
    if (!isPrivateHost(host)) {
      // –î–ª—è –ø—É–±–ª–∏—á–Ω—ã—Ö: –∞–ø–≥—Ä–µ–π–¥–∏–º http->https, –µ—Å–ª–∏ –±—ã–ª–æ http
      if (parsed.protocol === "http:") {
        parsed.protocol = "https:";
        u = parsed.toString();
      }
    } else {
      // –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ: –Ω–∏—á–µ–≥–æ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
      u = parsed.toString();
    }
  } catch {
    // –Ω–µ —Å–º–æ–≥–ª–∏ —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Å—Ç—Ä–æ–∫—É
  }

  // –õ—ë–≥–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö CDN
  const low = u.toLowerCase();
  const isCdn =
    low.includes("upload.wikimedia.org") ||
    low.includes("unsplash.com") ||
    low.includes("cloudinary.com");
  if (isCdn) {
    const hasQuery = u.includes("?");
    const hasW = /(?:[?&](?:w|width)=\d+)/i.test(u);
    if (!hasQuery && !hasW) u += "?auto=format,compress&q=80";
  }

  return u;
};

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ component ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const CustomImageRenderer = ({ tnode, contentWidth }: CustomImageRendererProps) => {
  const raw = pickSrc(tnode);
  const alt = tnode.attributes?.alt || "";
  if (!raw) return null;

  const src = useMemo(() => normalizeUrl(raw), [raw]);

  const attW = tnode.attributes?.width ? Number(tnode.attributes.width) : undefined;
  const attH = tnode.attributes?.height ? Number(tnode.attributes.height) : undefined;
  const attrAR = attW && attH && attH > 0 ? attW / attH : null;

  const { width: winW } = useWindowDimensions();
  const frameWidth = useMemo(
    () => Math.min(contentWidth || winW || MAX_WIDTH, MAX_WIDTH, (winW || MAX_WIDTH) - H_PADDING * 2),
    [contentWidth, winW]
  );

  const [ar, setAr] = useState<number | null>(attrAR ?? null);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);

  // –ü—Ä–µ–¥-–∑–∞–º–µ—Ä —Ä–∞–∑–º–µ—Ä–æ–≤: –ù–ï —Å—á–∏—Ç–∞–µ–º –æ—à–∏–±–∫–æ–π ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–∞–¥–∞–µ–º –Ω–∞ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π AR
  useEffect(() => {
    let mounted = true;
    setLoading(true);
    setImageLoaded(false);
    setErr(false);

    if (attrAR) {
      setAr(attrAR);
      setLoading(false);
      return () => { mounted = false; };
    }

    if (Platform.OS === "web") {
      const img = new (window as any).Image();
      img.decoding = "async";
      (img as any).loading = "lazy";
      (img as any).fetchPriority = "low";
      (img as any).referrerPolicy = "no-referrer";
      img.onload = () => {
        if (!mounted) return;
        if (img.naturalWidth && img.naturalHeight) setAr(img.naturalWidth / img.naturalHeight);
        setLoading(false);
      };
      img.onerror = () => {
        if (!mounted) return;
        setAr(null); // fallback
        setLoading(false);
      };
      img.src = src;
      return () => { mounted = false; };
    }

    RNImage.getSize(
      src,
      (w, h) => { if (mounted) { if (h > 0) setAr(w / h); setLoading(false); } },
      () => { if (mounted) { setAr(null); setLoading(false); } }
    );

    return () => { mounted = false; };
  }, [src, attrAR]);

  const aspect = ar && ar > 0 ? ar : 16 / 9;

  const webAttrs =
    Platform.OS === "web"
      ? ({
        loading: "lazy",
        decoding: "async",
        fetchPriority: "low",
        referrerPolicy: "no-referrer",
        sizes: `(min-width: ${MAX_WIDTH}px) ${MAX_WIDTH}px, 100vw`,
      } as any)
      : {};

  return (
    <View style={styles.container}>
      <View style={[styles.lightBorder, { width: frameWidth, padding: BORDER_PADDING }]}>
        <View style={[styles.ratioBox, { width: "100%", aspectRatio: aspect }]}>
          {/* skeleton */}
          {!imageLoaded && (
            <View pointerEvents="none" style={[StyleSheet.absoluteFillObject, styles.skeleton]}>
              <ActivityIndicator size="small" />
            </View>
          )}

          {/* –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ */}
          <ExpoImage
            source={{ uri: src }}
            style={[StyleSheet.absoluteFillObject, styles.image]}
            contentFit="contain"          // –Ω–µ —Ä–µ–∂–µ–º –∏ –Ω–µ —Ç—è–Ω–µ–º
            transition={200}
            cachePolicy="disk-memory"
            priority="low"
            accessibilityLabel={alt}
            accessibilityIgnoresInvertColors
            recyclingKey={src}
            onLoad={() => { setImageLoaded(true); }}
            onError={() => { setErr(true); }}
            {...webAttrs}
          />

          {/* –æ—à–∏–±–∫–∞ ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã–π onError */}
          {err && (
            <View style={[StyleSheet.absoluteFillObject, styles.errorContainer]}>
              <Text style={styles.errorText}>üì∑</Text>
              <Text style={styles.errorMessage}>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ</Text>
            </View>
          )}
        </View>
      </View>

      {alt && alt.toLowerCase() !== "image" && (
        <View style={[styles.captionContainer, { width: frameWidth }]}>
          <Text style={styles.caption} numberOfLines={3}>{alt}</Text>
        </View>
      )}
    </View>
  );
};

export default CustomImageRenderer;

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ styles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const styles = StyleSheet.create({
  container: {
    marginVertical: 24,
    alignItems: "center",
    paddingHorizontal: H_PADDING,
  },
  lightBorder: {
    borderRadius: 12,
    backgroundColor: "#fff",
    borderWidth: 1,
    borderColor: "#e9ecef",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
  },
  ratioBox: {
    borderRadius: 8,
    overflow: "hidden",
    backgroundColor: "#f4f6f8",
    position: "relative",
  },
  image: {
    borderRadius: 8,
    ...(Platform.OS === "web" ? ({ transition: "opacity 0.2s ease-in-out" } as any) : null),
  },
  skeleton: {
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#f4f6f8",
  },
  errorContainer: {
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#f4f6f8",
  },
  errorText: { fontSize: 32, marginBottom: 8 },
  errorMessage: { fontSize: 14, color: "#6c757d", textAlign: "center" },
  captionContainer: { marginTop: 12 },
  caption: {
    textAlign: "center",
    fontSize: 14,
    lineHeight: 20,
    color: "#495057",
    fontStyle: "italic",
  },
});
